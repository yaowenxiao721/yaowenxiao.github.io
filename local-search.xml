<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Database-System-Chapter-1</title>
    <link href="/2024/02/26/Database-System-Chapter-1/"/>
    <url>/2024/02/26/Database-System-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据库系统概述"><a href="#1-数据库系统概述" class="headerlink" title="1 - 数据库系统概述"></a>1 - 数据库系统概述</h1><h2 id="数据库的4个基本概念"><a href="#数据库的4个基本概念" class="headerlink" title="数据库的4个基本概念"></a>数据库的4个基本概念</h2><ul><li>Data( 数据 )<blockquote><p>*recode( 记录 )*：<strong>数据是有结构的</strong>，记录是计算机存储数据的一种格式或一种方法。 日常生活中人们可以直接用自然语言来描述事物，而在计算机中常常用记录+语义来描述。</p></blockquote></li><li>Database( 数据库 )</li><li>DataBase Management System( 数据库管理系统 )</li><li>DataBase System( 数据库系统 )</li></ul><h1 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2 - 数据模型"></a>2 - 数据模型</h1><h1 id="3-数据库系统的结构"><a href="#3-数据库系统的结构" class="headerlink" title="3 - 数据库系统的结构"></a>3 - 数据库系统的结构</h1><h1 id="4-数据库系统的组成"><a href="#4-数据库系统的组成" class="headerlink" title="4 - 数据库系统的组成"></a>4 - 数据库系统的组成</h1><h1 id="5-小结"><a href="#5-小结" class="headerlink" title="5 - 小结"></a>5 - 小结</h1>]]></content>
    
    
    <categories>
      
      <category>Database System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJUPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Live-Variable-Analysis-and-Iterative-Solver</title>
    <link href="/2024/02/23/Live-Variable-Analysis-and-Iterative-Solver/"/>
    <url>/2024/02/23/Live-Variable-Analysis-and-Iterative-Solver/</url>
    
    <content type="html"><![CDATA[<h1 id="作业导览"><a href="#作业导览" class="headerlink" title="作业导览"></a>作业导览</h1><ul><li>为 Java 实现一个活跃变量分析（Live Variable Analysis）。</li><li>实现一个通用的迭代求解器（Iterative Solver），用于求解数据流分析问题，也就是本次作业中的活跃变量分析。</li></ul><h1 id="实现LiveVariableAnalysis中的API"><a href="#实现LiveVariableAnalysis中的API" class="headerlink" title="实现LiveVariableAnalysis中的API"></a>实现LiveVariableAnalysis中的API</h1><ul><li><strong>SetFact newBoundaryFact(CFG)</strong></li><li><strong>SetFact newInitialFact()</strong></li><li><strong>void meetInto(SetFact,SetFact)</strong></li><li><strong>boolean transferNode(Stmt,SetFact,SetFact)</strong></li></ul><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/LiveVariableAnalysis.png" width=400><h2 id="1-newBoundaryFact-newInitialFact-CFG"><a href="#1-newBoundaryFact-newInitialFact-CFG" class="headerlink" title="1 - newBoundaryFact() &amp; newInitialFact(CFG)"></a>1 - newBoundaryFact() &amp; newInitialFact(CFG)</h2><p>由于是may分析，采用的是并运算符，且是正向传递的，所以每个BB的In都因该初始化为空。</p><p>pascal.taie.analysis.dataflow.fact.SetFact<Var></p><blockquote><p>这个泛型类用于把 data fact 组织成一个集合。它提供了各种集合操作，如添加、删除元素，取交集、并集等。你同样需要阅读源码和注释来理解如何使用这个类表示活跃变量分析中的各种 data fact。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.add(e);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.remove(e);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(SetFact&lt;E&gt; other)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.addAll(other.set);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>Set中add方法可以向集合中添加单个元素。</li><li>union使用数组工具类 Set 将参数 other 对象中的集合中的所有元素添加到当前对象的集合中，并返回添加操作是否成功的布尔值。</li></ul></blockquote></blockquote><h2 id="2-meetInto-SetFact-SetFact"><a href="#2-meetInto-SetFact-SetFact" class="headerlink" title="2 - meetInto(SetFact,SetFact)"></a>2 - meetInto(SetFact,SetFact)</h2><ul><li>该函数的功能就是将两个集合合并，所以直接采用union方法进行合并即可。</li><li>每个SetFact<Var>包括了一个Var集合的类成员和若干操作集合的方法，每个 node ( 程序点 )的 IN&#x2F;OUT 都拥有一个 SetFact<Var>. 初始化时因为 LiveVariableAnalysis 都要初始化为空集，返回 new 的值即可。</li></ul><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/meetInto.png" width=550><h2 id="3-transferNode-Stmt-SetFact-SetFact"><a href="#3-transferNode-Stmt-SetFact-SetFact" class="headerlink" title="3 - transferNode(Stmt,SetFact,SetFact)"></a>3 - transferNode(Stmt,SetFact,SetFact)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// out -&gt; newInfact</span><br>SetFact&lt;Var&gt; newInFact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>newInFact.union(out);   <br><br><span class="hljs-comment">// outFact - def</span><br><span class="hljs-keyword">if</span> (stmt.getDef().isPresent()) &#123; <br>    <span class="hljs-type">LValue</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> stmt.getDef().get();<br>    <span class="hljs-keyword">if</span> (def <span class="hljs-keyword">instanceof</span> Var) &#123;<br>        newInFact.remove((Var) def);<br>    &#125;<br>&#125;<span class="hljs-comment">// 因为表达式左边也就是def，是一个Var，所以直接用Optional来表示。</span><br><br><span class="hljs-comment">// (outFact - def ) + use</span><br><span class="hljs-keyword">for</span> (RValue use : stmt.getUses()) &#123;<br>    <span class="hljs-keyword">if</span> (use <span class="hljs-keyword">instanceof</span>  Var) &#123;<br>        newInFact.add((Var) use);<br>    &#125;<br>&#125;<span class="hljs-comment">// 因为表达式右也就是use，是可能存在多个值的，所以直接用List来表示。</span><br></code></pre></td></tr></table></figure><p>Java 8 Optional</p><ul><li>Optional 类是一个可以为null的容器对象。<strong>如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></li><li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li><li>Optional 类的引入很好的解决空指针异常。</li></ul><p>Java instanceof</p><ul><li>instanceof是Java中的二元运算符，<strong>左边是对象</strong>，<strong>右边是类</strong>；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</li></ul><p><em><strong>LValue &amp; RValue</strong></em><br>pascal.taie.ir.exp.Exp：是IR 中的一个关键接口，用于表示程序中的所有表达式。</p><ul><li>LValue:赋值语句左侧的表达式，如变量（x &#x3D; … ）、字段访问（x.f &#x3D; …）或数组访问（x[i] &#x3D; …）<blockquote><p>从outFact中remove掉def，需要用到LValue，因为定义是在表达式的左边，而def只有一个，故用Optional表示。</p></blockquote></li><li>RValue:赋值语句右侧的表达式，如数值字面量（… &#x3D; 1;）或二元表达式（… &#x3D; a + b;）<blockquote><p>从outFact中remove掉use，需要用到RValue，因为引用变量( use 变量 )是在表达式的右边，而use可能不止一个，故用List来表示。</p></blockquote></li></ul><p>getDef() &amp; getUses()</p><p>最后由于这个函数在伪代码中是需要判断前后值是否改变，且函数返回值的类型是boolean，所以需要添加判断语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!newInFact.equals(in)) &#123;<br>    in.set(newInFact);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h1 id="实现迭代求解器"><a href="#实现迭代求解器" class="headerlink" title="实现迭代求解器"></a>实现迭代求解器</h1><ul><li>Solver.initializeBackward(CFG,DataflowResult)</li><li>IterativeSolver.doSolveBackward(CFG,DataflowResult)</li></ul><p>相关提示：</p><blockquote><p>每个 Solver 对象都在字段 analysis 中保存了相应的数据流分析对象，在本次作业中就是一个 LiveVariableAnalysis 对象。你需要用它提供的相关接口来实现分析求解器。</p></blockquote><h2 id="1-Solver-initializeBackward-CFG-DataflowResult"><a href="#1-Solver-initializeBackward-CFG-DataflowResult" class="headerlink" title="1 - Solver.initializeBackward(CFG,DataflowResult)"></a>1 - Solver.initializeBackward(CFG,DataflowResult)</h2><p>实现伪代码：</p><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/initializeBackward.png" width=300><p>DataflowResult:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Fact <span class="hljs-title function_">getInFact</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">return</span> inFacts.get(node);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInFact</span><span class="hljs-params">(Node node, Fact fact)</span> &#123;<br>    inFacts.put(node, fact);<br>&#125;   <br></code></pre></td></tr></table></figure><blockquote><p>该类对象用于维护数据流分析的 CFG 中的 fact。可以通过它的 API 获取( get )、设置( set ) CFG 节点( node )的 IN facts 和 OUT facts。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    analysis.newBoundaryFact(cfg);<br>    <span class="hljs-keyword">for</span> (Node node : cfg.getNodes())&#123;<br>        <span class="hljs-keyword">if</span> ( cfg.isExit(node) )&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        result.setInFact(node, analysis.newInitialFact());<br>        result.setOutFact(node, analysis.newInitialFact());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>需要判断node是否到达exit( 末尾 )。</li></ul></blockquote><h2 id="2-IterativeSolver-doSolveBackward-CFG-DataflowResult"><a href="#2-IterativeSolver-doSolveBackward-CFG-DataflowResult" class="headerlink" title="2 - IterativeSolver.doSolveBackward(CFG,DataflowResult)"></a>2 - IterativeSolver.doSolveBackward(CFG,DataflowResult)</h2><p>实现伪代码：</p><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/doSolveBackward.png" width=300><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSolveBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (changed) &#123;<br>        changed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (Node node : cfg.getNodes()) &#123;<br>            <span class="hljs-keyword">if</span> (cfg.isExit(node)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (Node succNode : cfg.getSuccsOf(node)) &#123;<br>                analysis.meetInto(result.getInFact(succNode), result.getOutFact(node));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (analysis.transferNode(node, result.getInFact(node), result.getOutFact(node))) &#123;<br>                changed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>pascal.taie.analysis.graph.cfg.CFG</p><ul><li><p>通过一个 for 循环遍历其中的所有节点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CFG&lt;Node&gt; cfg = ...;<br>    <span class="hljs-keyword">for</span> (Node node : cfg) &#123;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 CFG.getPredsOf(Node) 和 CFG.getSuccsOf(Node) 这两个方法遍历 CFG 中节点的所有前驱和后继:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Node succ : cfg.getSuccsOf(node)) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis Programming Assignments</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tai-e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data-Flow-Analysis( Application )</title>
    <link href="/2024/02/20/Data-Flow-Analysis-I/"/>
    <url>/2024/02/20/Data-Flow-Analysis-I/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview-of-Data-Flow-Analysis"><a href="#Overview-of-Data-Flow-Analysis" class="headerlink" title="Overview of Data Flow Analysis"></a>Overview of Data Flow Analysis</h1><h2 id="1-Data-Flow-Analysis"><a href="#1-Data-Flow-Analysis" class="headerlink" title="1 - Data Flow Analysis"></a>1 - Data Flow Analysis</h2><p>Data Flow Analysis -&gt; How Data Flows on CFG<br>How <em>application-specific</em> Data( Abstraction ) <em>Flows</em>( Over-approximation ) through the <strong>Nodes</strong>( BB ) and <strong>Edges</strong>( control flows ) of CFG?</p><h1 id="Preliminaries-of-Data-Flow-Analysis"><a href="#Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="Preliminaries of Data Flow Analysis"></a>Preliminaries of Data Flow Analysis</h1><h2 id="1-Input-and-Output-States"><a href="#1-Input-and-Output-States" class="headerlink" title="1 - Input and Output States"></a>1 - Input and Output States</h2><ul><li>Each execution of an IR statement transforms an input state to a new output state.</li><li>The input( output ) state is associated with the program point before( after ) the statement.</li></ul><img src="/images/Data-Flow-Analysis-I/Input-Output.png" width=650><ul><li><p>In each data-flow analysis application, we associate with every program point a <strong>data-flow value</strong> that represents and <em>abstraction</em> of the set of all possible <strong>program states</strong> that can be abserved foe that point.</p><blockquote><p>在数据流分析应用中，将每一个 program point 与一个 表示该点所有观测到的 program states 的集合的抽象的数据流值（data-flow value） 联系起来。</p></blockquote></li><li><p>Data-flow analysis is to <strong>find a solution</strong> to a set of <em><strong>safe-approximation-directed constraints</strong></em> on the IN[s]’s and OUT[s]’s, for <em>all statements s.</em></p><ul><li>constraints based on semantics of statements( transfer functions ).</li><li>constraints baesd on the flows of control.<blockquote><p>数据流分析是对所有的语句，通过解析 safe-approximation 的约束规则，得到一个 solution（给每个 program point 一个 data-flow value）。</p></blockquote></li></ul></li></ul><h2 id="2-Notations-for-Transfer-Function’s-Constraints"><a href="#2-Notations-for-Transfer-Function’s-Constraints" class="headerlink" title="2 - Notations for Transfer Function’s Constraints"></a>2 - Notations for Transfer Function’s Constraints</h2><p>Forward &amp; Backward</p><img src="/images/Data-Flow-Analysis-I/Notations-Function.png" width=480><h2 id="3-Notations-for-Control-Flow’s-Constraints"><a href="#3-Notations-for-Control-Flow’s-Constraints" class="headerlink" title="3 - Notations for Control Flow’s Constraints"></a>3 - Notations for Control Flow’s Constraints</h2><p>Control flow within a BB &amp; Control flow among BBs</p><img src="/images/Data-Flow-Analysis-I/Notations-ControlFlow.png" width=550><h1 id="Reaching-Definitions-Analysis-定义可达性分析"><a href="#Reaching-Definitions-Analysis-定义可达性分析" class="headerlink" title="Reaching Definitions Analysis( 定义可达性分析 )"></a><em>Reaching Definitions Analysis( 定义可达性分析 )</em></h1><h2 id="1-Reaching-Definitions"><a href="#1-Reaching-Definitions" class="headerlink" title="1 - Reaching Definitions"></a>1 - Reaching Definitions</h2><p>A definition d at program point p reaches a point q if there is a path from p to q such that d is not “killed” along that path.</p><img src="/images/Data-Flow-Analysis-I/Reaching-Definitions.png" width=350><blockquote><ul><li>A definition of a variable v is a statement that assigns a value to v.</li><li>Translated as: definition of variable v at program point p reaches point q if there is a path from p to q such that <em><strong>no new definition of v</strong></em> appears on that path.</li></ul></blockquote><h2 id="2-Understanding-Reaching-Definitions"><a href="#2-Understanding-Reaching-Definitions" class="headerlink" title="2 - Understanding Reaching Definitions"></a>2 - Understanding Reaching Definitions</h2><p>定义可达性可以用于侦测可能的未定义的变量。</p><p>理解定义可达性分析：</p><ul><li><p>用一个比特表示某个变量在某一点的定义可达性。</p></li><li><p>用一个 n 维比特向量表示 n 个变量在某一点的定义可达性。</p></li><li><p>Data Flow Values&#x2F;Facts</p><blockquote><p>Represented by bit vectors  </p><img src="/images/Data-Flow-Analysis-I/bit-vectors.png" width=350>  </blockquote></li><li><p>Transfer Function</p><blockquote><img src="/images/Data-Flow-Analysis-I/TF.png" width=350>  <blockquote><p>genB就是B里面的definition,killB就是其他BB里面被覆盖掉的<br>definition。</p></blockquote></blockquote></li><li><p>Control Flow</p><blockquote><img src="/images/Data-Flow-Analysis-I/CF.png" width=350></blockquote></li></ul><h2 id="3-Algorithm-of-Reaching-Definitions-Analysis"><a href="#3-Algorithm-of-Reaching-Definitions-Analysis" class="headerlink" title="3 - Algorithm of Reaching Definitions Analysis"></a>3 - Algorithm of Reaching Definitions Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithm.png" width=500><blockquote><p>在算法模板中边界条件（OUT[entry]）单独初始化。<br>对于 OUT[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top。</p></blockquote><h2 id="4-Why-this-iterative-algorithm-can-finally-stop"><a href="#4-Why-this-iterative-algorithm-can-finally-stop" class="headerlink" title="4 - Why this iterative algorithm can finally stop?"></a>4 - Why this iterative algorithm can finally stop?</h2><p>对于 Transfer Function，OUT[S] 只受 IN[S] 的影响，当个更多的 facts 流入 IN[S] 时，要么被 kill 要么存活下来并永远被保留，故 OUT[S] <strong>永远不会缩减（e.g. 0 &#x3D;&gt; 1 或 1 &#x3D;&gt; 1）</strong>，又因为定义的变量数量是有限的，故该迭代一定会停下来（实际上到达了一个不动点）</p><blockquote><p>Reach a fixed point also related with monotonicity( 单调性 )</p></blockquote><h1 id="Live-Variables-Analysis-活跃变量分析"><a href="#Live-Variables-Analysis-活跃变量分析" class="headerlink" title="Live Variables Analysis( 活跃变量分析 )"></a><em>Live Variables Analysis( 活跃变量分析 )</em></h1><h2 id="1-Live-Variables-Define"><a href="#1-Live-Variables-Define" class="headerlink" title="1 - Live Variables Define"></a>1 - Live Variables Define</h2><p>Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at P. If so, v is live at p; otherwise, v is dead at p.</p><img src="/images/Data-Flow-Analysis-I/Live-Variables.png" width=500><blockquote><p>活跃变量信息可用于寄存器分配（倾向于使用存有 dead value 的寄存器来存新数据）</p></blockquote><h2 id="2-Understanding-Live-Variables-Analysis"><a href="#2-Understanding-Live-Variables-Analysis" class="headerlink" title="2 - Understanding Live Variables Analysis"></a>2 - Understanding Live Variables Analysis</h2><p>理解活跃变量分析：</p><ul><li>用一个比特表示某个变量在某一点是否活跃</li><li>用一个 n 维比特向量表示 n 个变量在某一点是否活跃</li></ul><img src="/images/Data-Flow-Analysis-I/Unerstanding-Live-Variables.png" width=650><blockquote><p>注意use的定义为：在重定义之前被使用。</p></blockquote><h2 id="3-Alogrithm-of-Live-Variables-Analysis"><a href="#3-Alogrithm-of-Live-Variables-Analysis" class="headerlink" title="3 - Alogrithm of Live Variables Analysis"></a>3 - Alogrithm of Live Variables Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithm-LV.png" width=650><blockquote><p>在算法模板中边界条件（IN[entry]）单独初始化<br>对于 IN[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p></blockquote><h1 id="Available-Expressions-Analysis-可用表达式分析"><a href="#Available-Expressions-Analysis-可用表达式分析" class="headerlink" title="Available Expressions Analysis( 可用表达式分析 )"></a><em>Available Expressions Analysis( 可用表达式分析 )</em></h1><h2 id="1-Available-Expressions-Define"><a href="#1-Available-Expressions-Define" class="headerlink" title="1 - Available Expressions Define"></a>1 - Available Expressions Define</h2><p>An expression <strong>x op y</strong> is available at program point p if (1) all paths from th entry to p must pass through the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x or y.</p><blockquote><p>一个表达式，形如 x op y，在某个 program point p 是可用的，需要满足：</p><ul><li>从 ENTRY 到 p 的所有路径都必须计算过 x op y 的值</li><li>在这些路径各自最后一次计算该表达式的值之后没有修改过 x 或 y 的值</li></ul></blockquote><h2 id="2-Understanding-Available-Expressions-Analysis"><a href="#2-Understanding-Available-Expressions-Analysis" class="headerlink" title="2 - Understanding Available Expressions Analysis"></a>2 - Understanding Available Expressions Analysis</h2><p>理解可用表达式分析：</p><ul><li>用一个比特表示某个表达式在某点是否可用</li><li>用一个 n 维比特向量表示 n 个表达式在某点是否可用</li><li>注意这是一个 must analysis</li></ul><img src="/images/Data-Flow-Analysis-I/Understanding-AE.png" width=650><blockquote><ul><li>传递函数和控制流函数如果所示，经过一个BB块的运算，将kill掉包含被重定义过变量的表达式，并加入新的表达式。</li><li>由于是must分析，所以控制流使用meet交集。</li><li>（may分析是只要有某条路径可以就行，must分析是所有路径都要满足才行。may一般用于检测是否使用并删除未使用，must用于替换）</li><li>must分析是一种safe并且under的approximation，即允许漏报的分析。看右下角例子，按照算法其实这个错了，第二个块由于x被重定义导致OUT应该变为空集的。如果由一种特殊情况，x被重定义为和原本一样的数值，那么这个表达式仍然是可以替换的，但是为了safe，算法还是把他排除了，这就是一种漏报，成为under-approximation。</li></ul></blockquote><h2 id="3-Algorithm-of-Available-Expressions-Analysis"><a href="#3-Algorithm-of-Available-Expressions-Analysis" class="headerlink" title="3 - Algorithm of Available Expressions Analysis"></a>3 - Algorithm of Available Expressions Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithmi-AE.png" width=650><h1 id="Analysis-Comparison"><a href="#Analysis-Comparison" class="headerlink" title="Analysis Comparison"></a>Analysis Comparison</h1><img src="/images/Data-Flow-Analysis-I/Analysis-Comparison.png" width=650><h1 id="The-X-You-Need-To-Understand-in-This-Lecture"><a href="#The-X-You-Need-To-Understand-in-This-Lecture" class="headerlink" title="The X You Need To Understand in This Lecture"></a>The X You Need To Understand in This Lecture</h1><ul><li>Understand the three data flow analyses:<blockquote><p>-reaching definitions<br>-live variables<br>-available expressions</p></blockquote></li><li>Can tell the differences and similarities of the three data flow analyses</li><li>Understand the iterative algorithm and cna tell why it is able to terminate</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intermediate-Representation</title>
    <link href="/2024/02/19/Intermediate-Representation/"/>
    <url>/2024/02/19/Intermediate-Representation/</url>
    
    <content type="html"><![CDATA[<h1 id="Compilers-and-Static-Analyzers"><a href="#Compilers-and-Static-Analyzers" class="headerlink" title="Compilers and Static Analyzers"></a>Compilers and Static Analyzers</h1><h2 id="1-Compiler"><a href="#1-Compiler" class="headerlink" title="1 - Compiler"></a>1 - Compiler</h2><p>Source Code -&gt; Scanner( 词法分析 ) -&gt; <em>Tokens</em> -&gt; Parser( 语法分析 ) -&gt; <em>AST</em> -&gt; Type Checker( 类型检查 ) -&gt; <em>Decorated AST</em> -&gt; Translatror -&gt; <em>IR</em> -&gt; Code Generator -&gt; Machine Code.</p><p>静态分析需要在编译器前端生成的 IR 的基础上进行代码优化。</p><h1 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h1><img src="/images/Intermediate-Representation/AST-IR.png" alt="AST vs. IR" width=550><h2 id="1-AST"><a href="#1-AST" class="headerlink" title="1 - AST"></a>1 - AST</h2><ul><li>high-level and closed to grammar structure.</li><li>usually language dependent.</li><li>suitable for fast type checking.</li><li>suitable for fast type checking.</li><li>lack of control flow information.</li></ul><h1 id="IR-Three-Address-Code-3AC"><a href="#IR-Three-Address-Code-3AC" class="headerlink" title="IR:Three-Address Code( 3AC )"></a>IR:Three-Address Code( 3AC )</h1><h2 id="1-Intermediate-Representation-IR-“3-address”-form"><a href="#1-Intermediate-Representation-IR-“3-address”-form" class="headerlink" title="1 - Intermediate Representation( IR “3-address” form )"></a>1 - Intermediate Representation( IR “3-address” form )</h2><ul><li>low-level and closed to machine code.</li><li>usually language independent.</li><li>compact and uniform.</li><li>contains control flow information.</li><li><strong>usually considered as the basis for static analysis</strong></li></ul><h2 id="2-Some-Common-3AC-Forms"><a href="#2-Some-Common-3AC-Forms" class="headerlink" title="2 - Some Common 3AC Forms"></a>2 - Some Common 3AC Forms</h2><ul><li>x &#x3D; y <em>bop</em> z</li><li>x &#x3D; <em>uop</em> y</li><li>x &#x3D; y</li><li>goto L</li><li>if x goto L</li><li>if x rop y goto L</li></ul><h1 id="3AC-in-Real-Static-Analyzer-Soot"><a href="#3AC-in-Real-Static-Analyzer-Soot" class="headerlink" title="3AC in Real Static Analyzer: Soot"></a>3AC in Real Static Analyzer: Soot</h1><h2 id="1-Some-real-world-complicated-forms"><a href="#1-Some-real-world-complicated-forms" class="headerlink" title="1 - Some real-world complicated forms"></a>1 - Some real-world complicated forms</h2><p>Java Src</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> nju.sa.examples;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class3AC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3AC(jimple)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">nju</span>.sa.examples.Class3AC <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Object<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> pi;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> &lt;init&gt;()<br>    &#123;<br>        nju.sa.examples.Class3AC r0;<br>        r0 := <span class="hljs-meta">@this</span>: nju.sa.examples.Class3AC;<br>        specialinvoke r0.&lt;java,lang.Object: <span class="hljs-keyword">void</span> &lt;init&gt;()&gt;();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span><br>    &#123;<br>        java.lang.String[] r0;<br>        r0 := <span class="hljs-meta">@parameter0</span>: java.lang.string[];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> &lt;clinit&gt;()<br>    &#123;<br>        &lt;nju.sa.examples.Class3AC: <span class="hljs-type">double</span> pi&gt; = <span class="hljs-number">3.14</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Static-Single-Assignment-SSA-–-Optional-material"><a href="#Static-Single-Assignment-SSA-–-Optional-material" class="headerlink" title="Static Single Assignment ( SSA ) – Optional material"></a>Static Single Assignment ( SSA ) – <em>Optional material</em></h1><p>All assignments in SSA are to variables with distinct names.</p><img src="/images/Intermediate-Representation/SSA.png" alt="SSA" width=400><p>Why not SSA?</p><ul><li>SSA may introduce too many variables and phi-functions.</li><li>May introduce inefficiency problem when translating to machine code (due to copy operations).</li></ul><h1 id="Basic-Blocks-BB"><a href="#Basic-Blocks-BB" class="headerlink" title="Basic Blocks( BB )"></a>Basic Blocks( BB )</h1><p>Define: Basic blocks( BB ) are maximal sequences of consecutive three-address instructions with the properties that</p><ul><li>It can be entered only at the beginning, i.e., the first instruction in the block.</li><li>It can be exited only at the end, i.e., the last instruction in the block.</li></ul><p><strong>How to build Basic Blocks?</strong></p><ul><li>Determine the leaders in P <blockquote><ul><li>The first instruciont in P is a leader.</li><li>Any target instruction of a conditional or unconditional jump is a leader.</li><li>Any instruction that immediately follows a conditional or unconditional jump is a leader.</li></ul></blockquote></li><li>Build BBs for P</li></ul><h1 id="Control-Flow-Graphs-CFG"><a href="#Control-Flow-Graphs-CFG" class="headerlink" title="Control Flow Graphs ( CFG )"></a>Control Flow Graphs ( CFG )</h1><p>How to build Control Flow Graph( CFG )</p><ul><li>The nodes of CFG are basic blocks.</li><li>There is an edge from block A to block B if and only if<blockquote><ul><li>There is a conditional or unconditional jump from the end of A to the beginning of B.</li><li>B immediately follows A in the original order of instructions <em>and A does not end in an unconditional jump</em>.</li></ul></blockquote></li><li>It is normal to replace the jumps to instruction labels by jumps to basic blocks.</li></ul><img src="/images/Intermediate-Representation/CFG.png" alt="Control Flow Graphs( CFG )" width=650><h1 id="The-X-You-Need-To-Understan-in-This-Lecture"><a href="#The-X-You-Need-To-Understan-in-This-Lecture" class="headerlink" title="The X You Need To Understan in This Lecture"></a>The X You Need To Understan in This Lecture</h1><ul><li>The relation between compilers and static analyhzers.</li><li>Understan 3AC and its common forms( in IR jimple ).</li><li>How to build basic blocks on top of IR.</li><li>How to construct control flow graphs on top of BBs?</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction</title>
    <link href="/2024/02/19/Introduction/"/>
    <url>/2024/02/19/Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h1><h2 id="1-Define"><a href="#1-Define" class="headerlink" title="1 - Define"></a>1 - Define</h2><p>静态分析通过分析程序 P 来推理其行为，并在运行 P 之前确定其是否满足某些属性。</p><blockquote><p>Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P.</p></blockquote><ul><li>Does P contain any private information leaks?</li><li>Does P dereference any null pointers?</li><li>Are all the cast operations in P safe?<br><em>- 是否存在强制类型转换异常？</em></li><li>Can v1 and v2 in P point to the same memory location?</li><li>Will certain assert staements in P fail?<br><em>- 是否存在 fail 的 assert 语句？</em></li><li>Is this piece of code in P dead(so that it could be eliminated?)<br><em>- 是否存在可以删除的死代码？</em></li></ul><h2 id="2-Rice’s-Theorem-莱斯定理"><a href="#2-Rice’s-Theorem-莱斯定理" class="headerlink" title="2 - Rice’s Theorem(莱斯定理)"></a>2 - Rice’s Theorem(莱斯定理)</h2><p>通俗的讲：不存在完美的静态分析方法(Perfect static analysis)。</p><blockquote><p>Perfect static &#x3D; Sound &amp; Complete</p></blockquote><img src="/images/Introduction/Sound-Complete.png" width=500 /><p>真正的有用的静态分析：妥协soundness或者completeness。</p><blockquote><p>Useful static analysis &#x3D; Compromise soundness OR Compromise completeness</p><blockquote><p>Compromise soundness:产生漏报( false negatives ) ( 可以接受 )<br>Compromise completeness:产生误报( false positives ) ( 不希望发生 )</p></blockquote></blockquote><h2 id="3-Static-Analysis-–Bird’s-Eye-View-整体概括"><a href="#3-Static-Analysis-–Bird’s-Eye-View-整体概括" class="headerlink" title="3 - Static Analysis –Bird’s Eye View( 整体概括 )"></a>3 - Static Analysis –Bird’s Eye View( 整体概括 )</h2><p>打破动态思维，从静态分析角度分析代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(input)<br>    x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>    x = <span class="hljs-number">0</span>;<br>-&gt; x = ?<br></code></pre></td></tr></table></figure><p>Sound: x &#x3D; 0, 1, 2, 3<br>Unsound: x &#x3D; -1, 0</p><img src="/images/Introduction/Two-Results.png" width=300 /><p><strong>Static Analysis</strong>: ensure( or get close to )<em>soundness</em>, while making good trade-offs between analysis <em>precision</em> and analysis <em>speed</em>.</p><blockquote><p>在确保 soundness 的前提下，在分析的准确度和速度之间做出有效的平衡。</p></blockquote><h1 id="Two-Words-to-Conclude-Static-Analysis"><a href="#Two-Words-to-Conclude-Static-Analysis" class="headerlink" title="Two Words to Conclude Static Analysis"></a>Two Words to Conclude Static Analysis</h1><h2 id="1-Comprehension"><a href="#1-Comprehension" class="headerlink" title="1 - Comprehension"></a>1 - Comprehension</h2><p><strong>Abstraction + Over - approximation</strong></p><blockquote><p>Abstraction（ 抽象 ）：把具体域的值映射到抽象域的值。</p></blockquote><blockquote><p>Over - approximation（ 近似 ）：在抽象层面定义转移函数；由于无法枚举所有路径，所以使用 flow merging 处理 control flow。</p></blockquote><h1 id="Focus-of-this-section"><a href="#Focus-of-this-section" class="headerlink" title="Focus of this section"></a>Focus of this section</h1><ul><li>静态分析与（动态）测试的区别？</li><li>理解 soundness, completeness, false negatives 和 false positives 的概念</li><li>为什么静态分析需要保证 soundness？</li><li>怎样理解 abstraction 和 over-approximation？</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning Markdown~</title>
    <link href="/2024/02/19/Learning-Markdown/"/>
    <url>/2024/02/19/Learning-Markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Markdonw"><a href="#一、Markdonw" class="headerlink" title="一、Markdonw"></a>一、Markdonw</h2><p>一款轻量级标记语言。</p><h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h3><blockquote><p>这是一段引用。</p></blockquote><h3 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>把大象放进冰箱：</p><ol><li>打开冰箱。</li><li>把大象塞进冰箱。</li><li>关上冰箱。</li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>Markdown</li><li>is</li><li>very</li><li>nice</li></ul><h3 id="Todo："><a href="#Todo：" class="headerlink" title="Todo："></a>Todo：</h3><ul><li><input disabled="" type="checkbox"> sleep</li><li><input checked="" disabled="" type="checkbox"> eat</li></ul><h3 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h3><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">16</td><td align="center">89</td></tr><tr><td align="left">李四</td><td align="right">17</td><td align="center">90</td></tr><tr><td align="left">王五</td><td align="right">17</td><td align="center">95</td></tr></tbody></table><h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p><a href="github.com" title="代码开源网站">GitHub</a><br><a href="github.com" title="代码开源网站">github</a></p><h3 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h3><p><em>斜体</em>,加粗,<code>printf()</code>,:smile:,H<del>2</del>O,X^2^,&#x3D;&#x3D;高亮文字&#x3D;&#x3D;</p><h3 id="嵌入式代码："><a href="#嵌入式代码：" class="headerlink" title="嵌入式代码："></a>嵌入式代码：</h3><iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guangyuan Bacchus Garden Lantern Festival</title>
    <link href="/2024/02/18/%E5%B9%BF%E5%85%83%E7%99%BE%E8%8D%89%E5%9B%AD%E7%81%AF%E4%BC%9A/"/>
    <url>/2024/02/18/%E5%B9%BF%E5%85%83%E7%99%BE%E8%8D%89%E5%9B%AD%E7%81%AF%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<img src="/images/广元百草园灯会/1.jpg"  /><img src="/images/广元百草园灯会/2.jpg"  /><img src="/images/广元百草园灯会/3.jpg"  /><img src="/images/广元百草园灯会/4.jpg"  /><img src="/images/广元百草园灯会/5.jpg"  /><img src="/images/广元百草园灯会/6.jpg"  /><img src="/images/广元百草园灯会/7.jpg"  /><img src="/images/广元百草园灯会/8.jpg"  /><img src="/images/广元百草园灯会/9.jpg"  /><img src="/images/广元百草园灯会/10.jpg"  /><img src="/images/广元百草园灯会/11.jpg"  /><img src="/images/广元百草园灯会/12.jpg"  /><img src="/images/广元百草园灯会/13.jpg"  />]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lantern Festival</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/15/hello-world/"/>
    <url>/2024/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
