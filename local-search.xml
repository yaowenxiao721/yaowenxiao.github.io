<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Constan Propagation and Worklist Solver</title>
    <link href="/2024/02/28/Constan-Propagation-and-Worklist-Solver/"/>
    <url>/2024/02/28/Constan-Propagation-and-Worklist-Solver/</url>
    
    <content type="html"><![CDATA[<h1 id="作业导览"><a href="#作业导览" class="headerlink" title="作业导览"></a>作业导览</h1><ul><li>为 Java 实现常量传播算法。</li><li>实现一个通用的 worklist 求解器，并用它来解决一些数据流分析问题，例如本次的常量传播。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis Programming Assignments</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tai-e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Flow Analysis( Foundations )</title>
    <link href="/2024/02/27/Data-Flow-Analysis-Foundations/"/>
    <url>/2024/02/27/Data-Flow-Analysis-Foundations/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Iterative-Algorithm-Another-View"><a href="#1-Iterative-Algorithm-Another-View" class="headerlink" title="1 - Iterative Algorithm, Another View"></a>1 - Iterative Algorithm, Another View</h1><ul><li>假设给定的 CFG 有 k 个节点，迭代算法每次迭代更新每个节点的 OUT[n]</li><li>定义 k-tuple (OUT[n1], … , OUT[nk])，则该元组为集合 V^k 的一个元素（V 是数据流分析的值的域）</li><li>那么每次迭代可以视作作用了转移函数和流控制处理的一次映射，即：F: V^k —&gt; V^k</li><li>整个算法就是在不断地输出这样的 k-tuple 直到出现连续两个相同的为止</li></ul><img src="/images/Data-Flow-Analysis-Foundations/Another-View.png"><blockquote><p>迭代算法会在 X &#x3D; F(X) 处停下来，即数学定义上的一个不动点（fixed point）</p></blockquote><p>Think:</p><ul><li>Is the algorithm guaranteed to terminate or reach the fixed point, or does it always have a solution?</li><li>If so, is there only one solution or only one fixed point? If more than one, is our solution the best one (most precise)?</li><li>When will the algorithm reach the fixed point, or when can we get the solution? (时间复杂度)</li></ul><h1 id="2-Partial-Order"><a href="#2-Partial-Order" class="headerlink" title="2- Partial Order"></a>2- Partial Order</h1><ul><li>偏序关系（Partial Order）满足<strong>自反性</strong>、<strong>反对称性</strong>、<strong>传递性</strong>。</li><li>一个偏序集（poset）中的任意两个元素之间不一定满足偏序关系</li></ul><img src="/images/Data-Flow-Analysis-Foundations/Partial-Order.png" width=550><h1 id="3-Upper-and-Lower-Bounds"><a href="#3-Upper-and-Lower-Bounds" class="headerlink" title="3 - Upper and Lower Bounds"></a>3 - Upper and Lower Bounds</h1><p>上界（upper bound）和下界（lower bound）<br><img src="/images/Data-Flow-Analysis-Foundations/ul-bound.png" width=450></p><p>最小上界（least upper bound）和最大下界（greatest lower bound）<br><img src="/images/Data-Flow-Analysis-Foundations/least-ul-bound.png" width=500></p><blockquote><p>不是每个偏序集都有最小上界（最大下界）；若偏序集存在最小上界（最大下界），则是唯一的</p></blockquote><h1 id="4-Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#4-Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="4 - Lattice, Semilattice, Complete and Product Lattice"></a>4 - Lattice, Semilattice, Complete and Product Lattice</h1><ul><li>格（Lattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/lattice.png" width=500><ul><li>半格（Semilattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/semilattice.png" width=500><ul><li>全格（Complete Lattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/complete-lattice.png" width=500><blockquote><p>Every <strong>finite</strong> lattice (P is finite) is a complete lattice. ( 有穷格一定是全格，全格不一定是有穷格 )</p></blockquote><ul><li>格的积（Product Lattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/product-lattice.png" width=500><blockquote><ul><li>A product lattice is a lattice.</li><li>If a product lattice L is a product of complete lattices, then L is also complete.</li></ul></blockquote><h1 id="5-Data-Flow-Analysis-Framework-via-Lattice"><a href="#5-Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="5 - Data Flow Analysis Framework via Lattice"></a>5 - Data Flow Analysis Framework via Lattice</h1><p>A data flow analysis framework (D, L, F) consists of:</p><ul><li>D: a direction of data flow: forwards or backwards.</li><li>L: a lattice including domain of the values V and a meet ∩ or join ∪ operator.</li><li>F: a family of transfer functions from V to V.<blockquote><p>Data flow analysis can be seen as iteratively applying transfer functions and meet&#x2F;join operations on the values of a lattice.</p></blockquote></li></ul><h1 id="6-Monotonicity-and-Fixed-Point-Theorem"><a href="#6-Monotonicity-and-Fixed-Point-Theorem" class="headerlink" title="6 - Monotonicity and Fixed Point Theorem"></a>6 - Monotonicity and Fixed Point Theorem</h1><h2 id="Monotonicity-Define："><a href="#Monotonicity-Define：" class="headerlink" title="Monotonicity Define："></a>Monotonicity Define：</h2><p>一个函数f: L → L (L为lattice)是单调的，当且仅当∀x, y ∈ L,x ⊑ y ⟹ f(x) ⊑ f(y)。</p><h2 id="Fixed-Point-Theorem"><a href="#Fixed-Point-Theorem" class="headerlink" title="Fixed Point Theorem"></a>Fixed Point Theorem</h2><img src="/images/Data-Flow-Analysis-Foundations/fixed-point.png" width=500><p>Let’s prove</p><ul><li>Existence of fixed point.</li><li>The fixed point is the least.</li></ul><h1 id="7-Relate-Iteraive-Algorithm-to-Fixed-Point-Theorem"><a href="#7-Relate-Iteraive-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="7 - Relate Iteraive Algorithm to Fixed Point Theorem"></a>7 - Relate Iteraive Algorithm to Fixed Point Theorem</h1><img src="/images/Data-Flow-Analysis-Foundations/relate.png" width=500><h1 id="8-May-Must-Analysis-A-Lattice-View"><a href="#8-May-Must-Analysis-A-Lattice-View" class="headerlink" title="8 - May&#x2F;Must Analysis, A Lattice View"></a><em>8 - May&#x2F;Must Analysis, A Lattice View</em></h1><img src="/images/Data-Flow-Analysis-Foundations/May-Must-Analysis.png" width=550><blockquote><ul><li>may分析的目的可以看作是报错，因此初始化在bottom，此时分析结果为无错误，因此肯定是一个unsafe的结果；而在top处，分析结果是所有点都出错的，这个肯定是safe的，但是就有些是做了无用功了；因此我们的目的是在二者之间找到一个平衡点，假设{a,c}是truth，那么以此为界可以划分为两块(之所以是区域是因为这其实是一个product lattice)，交界点便是truth。</li><li>must的目的可以看作是删除优化，因此初始化在top，此时分析结果为所有语句都可删除，那肯定是unsafe的，其余类比may可得。</li><li>会发现may分析是查错用的，所以必须都是1才安全，而must是优化用的，所以都是0才最安全，无论是MUST还&gt;是MAY，都是从Unsafe往Safe方向走，达到第一个不动点。</li><li>就是用之前 {a, b, c} 的图来理解，现在有一个 {a} 和 一个 {b}，它们固然可以走到 {a, b, c}，但是它们的 join 是 {a, b}</li><li>图中所有不动点都是safe的，其实是看算法设计情况，如果由不动点在unsafe区域，那么这个算法就是不合格的。</li></ul></blockquote><h1 id="9-Distributivity-and-MOP"><a href="#9-Distributivity-and-MOP" class="headerlink" title="9 - Distributivity and MOP"></a>9 - Distributivity and MOP</h1><ul><li>Meet-Over-All-Paths Solution (MOP)</li></ul><blockquote><p>与之前使用的算法不同，我们以前使用的算法是在运行过程中沿着数据流反复迭代的，而MOP是找出从开头到结尾所有路径，分别进行传递函数计算，最后将算完的所有路径进行⊔&#x2F;⊓</p></blockquote><img src="/images/Data-Flow-Analysis-Foundations/MOP.png" width=500><blockquote><p>由于某些路径可能实际无法到达，因此MOP不是特别精确；而在正常的程序中路径过多，几乎无法全部枚举，因此MOP也不太实际。</p></blockquote><ul><li>Iterative Algorithm vs. MOP<blockquote><p>iterative algorithm: F(x ∪ y)<br>MOP: F(X) ∪ F(y)</p></blockquote></li></ul><p>经过证明MOP ⊑ Ours满足偏序关系，根据之前的图，对于may analyses，MOP更加接近truth因此更加精确。<br>同理，对于must analyses，有Ours ⊑ MOP，根据之前的图，MOP接近truth，更加精准。<br>只要满足了转换函数是distributive的条件，我们的方法就和MOP一样精准，上一篇文章中提到的三个算法都是distributive，下面将一个不是distributive的算法。</p><h1 id="10-Constant-Propagation"><a href="#10-Constant-Propagation" class="headerlink" title="10 - Constant Propagation"></a>10 - Constant Propagation</h1><h2 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h2><p>Given a variable x at program point p, determine whether x is guaranteed to hold a constant value at p.</p><ul><li>The OUT of each node in CFG, includes a set of pairs (x, v) where x is a variable and v is the value held by x after that node.</li></ul><h1 id="11-Worklist-Algorithm"><a href="#11-Worklist-Algorithm" class="headerlink" title="11 - Worklist Algorithm"></a>11 - Worklist Algorithm</h1>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Database System Chapter 1</title>
    <link href="/2024/02/26/Database-System-Chapter-1/"/>
    <url>/2024/02/26/Database-System-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据库系统概述"><a href="#1-数据库系统概述" class="headerlink" title="1 - 数据库系统概述"></a>1 - 数据库系统概述</h1><h2 id="数据库的4个基本概念"><a href="#数据库的4个基本概念" class="headerlink" title="数据库的4个基本概念"></a>数据库的4个基本概念</h2><ul><li>Data( 数据 )<blockquote><p>*recode( 记录 )*：<strong>数据是有结构的</strong>，记录是计算机存储数据的一种格式或一种方法。 日常生活中人们可以直接用自然语言来描述事物，而在计算机中常常用记录+语义来描述。</p></blockquote></li><li>Database( 数据库 )<blockquote><p>是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p></blockquote></li><li>DataBase Management System( 数据库管理系统 )<blockquote><ul><li>位于用户应用与操作系统之间的一层数据管理软件。</li><li>是基础软件，是一个大型复杂的软件系统。<img src="/images/Database-System-Chapter-1/DBMS.png" width=120></li></ul></blockquote></li><li>DataBase System( 数据库系统 )<blockquote><p>是指在计算机系统中引入数据库后的系统构成(对数据进行存储、管理、处理和维护的系统)</p></blockquote></li></ul><h2 id="DBMS-的功能："><a href="#DBMS-的功能：" class="headerlink" title="DBMS 的功能："></a>DBMS 的功能：</h2><ul><li>数据定义、组织、存储和管理、操纵</li><li>数据库的事务管理和运行管理（安全性、完整性、并发控制、恢复）</li><li>数据库的建立和维护</li></ul><h2 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h2><ul><li>数据结构化<blockquote><p>数据的<strong>整体</strong>结构化是数据库的主要特征之一</p></blockquote></li><li>数据的共享性高，冗余度低且易扩充<blockquote><p>数据面向整个系统，可以被多个用户、多个应用共享使用。<br><img src="/images/Database-System-Chapter-1/share.png" width=400></p></blockquote></li><li>数据独立性强<blockquote><p>数据独立性由数据库管理系统的二级映像功能来保证</p></blockquote></li><li>数据由数据库管理系统统一管理和控制<blockquote><ul><li>数据的安全性（Security）保护</li><li>数据的完整性（Integrity）检查</li><li>并发控制（Concurrency Control）</li><li>数据库恢复（Recovery）</li></ul></blockquote></li></ul><h1 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2 - 数据模型"></a>2 - 数据模型</h1><p>数据模型是对现实世界数据特征的抽象</p><p><strong>数据模型的组成要素</strong>：</p><ul><li><p>数据结构–描述系统的静态特性</p></li><li><p>数据操作–描述系统的动态特性</p></li><li><p>完整性约束–给定的数据模型中数据及其联系所具有的制约和<br>依存规则。</p></li><li><p>概念模型：<br>实体-联系方法（Entity-Relationship Approach）（E-T模型）：</p></li></ul><img src="/images/Database-System-Chapter-1/E-R.png" width=500><ul><li><p><strong>逻辑模型</strong>：</p><blockquote><p>层次结构-层次模型、网状结构–网状模型、关系结构—关系模型</p></blockquote></li><li><p>物理模型</p></li></ul><h1 id="3-数据库系统的结构"><a href="#3-数据库系统的结构" class="headerlink" title="3 - 数据库系统的结构"></a>3 - 数据库系统的结构</h1><ul><li>模式（Schema）<blockquote><p>是对数据库逻辑结构和特征的描述<br>是型的描述，不涉及具体值<br>模式是相对稳定的</p></blockquote></li><li>实例（Instance）<blockquote><p>数据库某一时刻的状态——模式的一个具体值<br>同一个模式可以有很多实例<br>n实例随数据库中的数据的更新而变动</p></blockquote></li></ul><p>数据库系统的三级模式结构:</p><img src="/images/Database-System-Chapter-1/三级模式.png" width=600><blockquote><ul><li>外模式（也称子模式或用户模式）</li><li>模式（逻辑模式）</li><li>内模式（也称存储模式）（一个数据库只有一个内模式）</li></ul></blockquote><p>数据库的二级映像功能</p><ul><li>外模式／模式映像</li><li>模式／内模式映像<blockquote><p>数据独立性（物理独立性、逻辑独立性）由数据库管理系统的二级映像功能来保证。</p><ul><li>物理独立性是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。</li><li>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</li></ul></blockquote></li></ul><h1 id="4-数据库系统的组成（略）"><a href="#4-数据库系统的组成（略）" class="headerlink" title="4 - 数据库系统的组成（略）"></a>4 - 数据库系统的组成（略）</h1>]]></content>
    
    
    <categories>
      
      <category>Database System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJUPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Live Variable Analysis and Iterative Solver</title>
    <link href="/2024/02/23/Live-Variable-Analysis-and-Iterative-Solver/"/>
    <url>/2024/02/23/Live-Variable-Analysis-and-Iterative-Solver/</url>
    
    <content type="html"><![CDATA[<h1 id="作业导览"><a href="#作业导览" class="headerlink" title="作业导览"></a>作业导览</h1><ul><li>为 Java 实现一个活跃变量分析（Live Variable Analysis）。</li><li>实现一个通用的迭代求解器（Iterative Solver），用于求解数据流分析问题，也就是本次作业中的活跃变量分析。</li></ul><h1 id="实现LiveVariableAnalysis中的API"><a href="#实现LiveVariableAnalysis中的API" class="headerlink" title="实现LiveVariableAnalysis中的API"></a>实现LiveVariableAnalysis中的API</h1><ul><li><strong>SetFact newBoundaryFact(CFG)</strong></li><li><strong>SetFact newInitialFact()</strong></li><li><strong>void meetInto(SetFact,SetFact)</strong></li><li><strong>boolean transferNode(Stmt,SetFact,SetFact)</strong></li></ul><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/LiveVariableAnalysis.png" width=400><h2 id="1-newBoundaryFact-newInitialFact-CFG"><a href="#1-newBoundaryFact-newInitialFact-CFG" class="headerlink" title="1 - newBoundaryFact() &amp; newInitialFact(CFG)"></a>1 - newBoundaryFact() &amp; newInitialFact(CFG)</h2><p>由于是may分析，采用的是并运算符，且是正向传递的，所以每个BB的In都因该初始化为空。</p><p>pascal.taie.analysis.dataflow.fact.SetFact<Var></p><blockquote><p>这个泛型类用于把 data fact 组织成一个集合。它提供了各种集合操作，如添加、删除元素，取交集、并集等。你同样需要阅读源码和注释来理解如何使用这个类表示活跃变量分析中的各种 data fact。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.add(e);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.remove(e);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(SetFact&lt;E&gt; other)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.addAll(other.set);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>Set中add方法可以向集合中添加单个元素。</li><li>union使用数组工具类 Set 将参数 other 对象中的集合中的所有元素添加到当前对象的集合中，并返回添加操作是否成功的布尔值。</li></ul></blockquote></blockquote><h2 id="2-meetInto-SetFact-SetFact"><a href="#2-meetInto-SetFact-SetFact" class="headerlink" title="2 - meetInto(SetFact,SetFact)"></a>2 - meetInto(SetFact,SetFact)</h2><ul><li>该函数的功能就是将两个集合合并，所以直接采用union方法进行合并即可。</li><li>每个SetFact<Var>包括了一个Var集合的类成员和若干操作集合的方法，每个 node ( 程序点 )的 IN&#x2F;OUT 都拥有一个 SetFact<Var>. 初始化时因为 LiveVariableAnalysis 都要初始化为空集，返回 new 的值即可。</li></ul><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/meetInto.png" width=550><h2 id="3-transferNode-Stmt-SetFact-SetFact"><a href="#3-transferNode-Stmt-SetFact-SetFact" class="headerlink" title="3 - transferNode(Stmt,SetFact,SetFact)"></a>3 - transferNode(Stmt,SetFact,SetFact)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// out -&gt; newInfact</span><br>SetFact&lt;Var&gt; newInFact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>newInFact.union(out);   <br><br><span class="hljs-comment">// outFact - def</span><br><span class="hljs-keyword">if</span> (stmt.getDef().isPresent()) &#123; <br>    <span class="hljs-type">LValue</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> stmt.getDef().get();<br>    <span class="hljs-keyword">if</span> (def <span class="hljs-keyword">instanceof</span> Var) &#123;<br>        newInFact.remove((Var) def);<br>    &#125;<br>&#125;<span class="hljs-comment">// 因为表达式左边也就是def，是一个Var，所以直接用Optional来表示。</span><br><br><span class="hljs-comment">// (outFact - def ) + use</span><br><span class="hljs-keyword">for</span> (RValue use : stmt.getUses()) &#123;<br>    <span class="hljs-keyword">if</span> (use <span class="hljs-keyword">instanceof</span>  Var) &#123;<br>        newInFact.add((Var) use);<br>    &#125;<br>&#125;<span class="hljs-comment">// 因为表达式右也就是use，是可能存在多个值的，所以直接用List来表示。</span><br></code></pre></td></tr></table></figure><p>Java 8 Optional</p><ul><li>Optional 类是一个可以为null的容器对象。<strong>如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></li><li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li><li>Optional 类的引入很好的解决空指针异常。</li></ul><p>Java instanceof</p><ul><li>instanceof是Java中的二元运算符，<strong>左边是对象</strong>，<strong>右边是类</strong>；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</li></ul><p><em><strong>LValue &amp; RValue</strong></em><br>pascal.taie.ir.exp.Exp：是IR 中的一个关键接口，用于表示程序中的所有表达式。</p><ul><li>LValue:赋值语句左侧的表达式，如变量（x &#x3D; … ）、字段访问（x.f &#x3D; …）或数组访问（x[i] &#x3D; …）<blockquote><p>从outFact中remove掉def，需要用到LValue，因为定义是在表达式的左边，而def只有一个，故用Optional表示。</p></blockquote></li><li>RValue:赋值语句右侧的表达式，如数值字面量（… &#x3D; 1;）或二元表达式（… &#x3D; a + b;）<blockquote><p>从outFact中remove掉use，需要用到RValue，因为引用变量( use 变量 )是在表达式的右边，而use可能不止一个，故用List来表示。</p></blockquote></li></ul><p>getDef() &amp; getUses()</p><p>最后由于这个函数在伪代码中是需要判断前后值是否改变，且函数返回值的类型是boolean，所以需要添加判断语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!newInFact.equals(in)) &#123;<br>    in.set(newInFact);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h1 id="实现迭代求解器"><a href="#实现迭代求解器" class="headerlink" title="实现迭代求解器"></a>实现迭代求解器</h1><ul><li>Solver.initializeBackward(CFG,DataflowResult)</li><li>IterativeSolver.doSolveBackward(CFG,DataflowResult)</li></ul><p>相关提示：</p><blockquote><p>每个 Solver 对象都在字段 analysis 中保存了相应的数据流分析对象，在本次作业中就是一个 LiveVariableAnalysis 对象。你需要用它提供的相关接口来实现分析求解器。</p></blockquote><h2 id="1-Solver-initializeBackward-CFG-DataflowResult"><a href="#1-Solver-initializeBackward-CFG-DataflowResult" class="headerlink" title="1 - Solver.initializeBackward(CFG,DataflowResult)"></a>1 - Solver.initializeBackward(CFG,DataflowResult)</h2><p>实现伪代码：</p><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/initializeBackward.png" width=300><p>DataflowResult:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Fact <span class="hljs-title function_">getInFact</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">return</span> inFacts.get(node);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInFact</span><span class="hljs-params">(Node node, Fact fact)</span> &#123;<br>    inFacts.put(node, fact);<br>&#125;   <br></code></pre></td></tr></table></figure><blockquote><p>该类对象用于维护数据流分析的 CFG 中的 fact。可以通过它的 API 获取( get )、设置( set ) CFG 节点( node )的 IN facts 和 OUT facts。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    analysis.newBoundaryFact(cfg);<br>    <span class="hljs-keyword">for</span> (Node node : cfg.getNodes())&#123;<br>        <span class="hljs-keyword">if</span> ( cfg.isExit(node) )&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        result.setInFact(node, analysis.newInitialFact());<br>        result.setOutFact(node, analysis.newInitialFact());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>需要判断node是否到达exit( 末尾 )。</li></ul></blockquote><h2 id="2-IterativeSolver-doSolveBackward-CFG-DataflowResult"><a href="#2-IterativeSolver-doSolveBackward-CFG-DataflowResult" class="headerlink" title="2 - IterativeSolver.doSolveBackward(CFG,DataflowResult)"></a>2 - IterativeSolver.doSolveBackward(CFG,DataflowResult)</h2><p>实现伪代码：</p><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/doSolveBackward.png" width=300><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSolveBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (changed) &#123;<br>        changed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (Node node : cfg.getNodes()) &#123;<br>            <span class="hljs-keyword">if</span> (cfg.isExit(node)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (Node succNode : cfg.getSuccsOf(node)) &#123;<br>                analysis.meetInto(result.getInFact(succNode), result.getOutFact(node));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (analysis.transferNode(node, result.getInFact(node), result.getOutFact(node))) &#123;<br>                changed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>pascal.taie.analysis.graph.cfg.CFG</p><ul><li><p>通过一个 for 循环遍历其中的所有节点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CFG&lt;Node&gt; cfg = ...;<br>    <span class="hljs-keyword">for</span> (Node node : cfg) &#123;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 CFG.getPredsOf(Node) 和 CFG.getSuccsOf(Node) 这两个方法遍历 CFG 中节点的所有前驱和后继:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Node succ : cfg.getSuccsOf(node)) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis Programming Assignments</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tai-e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Flow Analysis( Application )</title>
    <link href="/2024/02/20/Data-Flow-Analysis-I/"/>
    <url>/2024/02/20/Data-Flow-Analysis-I/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview-of-Data-Flow-Analysis"><a href="#Overview-of-Data-Flow-Analysis" class="headerlink" title="Overview of Data Flow Analysis"></a>Overview of Data Flow Analysis</h1><h2 id="1-Data-Flow-Analysis"><a href="#1-Data-Flow-Analysis" class="headerlink" title="1 - Data Flow Analysis"></a>1 - Data Flow Analysis</h2><p>Data Flow Analysis -&gt; How Data Flows on CFG<br>How <em>application-specific</em> Data( Abstraction ) <em>Flows</em>( Over-approximation ) through the <strong>Nodes</strong>( BB ) and <strong>Edges</strong>( control flows ) of CFG?</p><h1 id="Preliminaries-of-Data-Flow-Analysis"><a href="#Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="Preliminaries of Data Flow Analysis"></a>Preliminaries of Data Flow Analysis</h1><h2 id="1-Input-and-Output-States"><a href="#1-Input-and-Output-States" class="headerlink" title="1 - Input and Output States"></a>1 - Input and Output States</h2><ul><li>Each execution of an IR statement transforms an input state to a new output state.</li><li>The input( output ) state is associated with the program point before( after ) the statement.</li></ul><img src="/images/Data-Flow-Analysis-I/Input-Output.png" width=650><ul><li><p>In each data-flow analysis application, we associate with every program point a <strong>data-flow value</strong> that represents and <em>abstraction</em> of the set of all possible <strong>program states</strong> that can be abserved foe that point.</p><blockquote><p>在数据流分析应用中，将每一个 program point 与一个 表示该点所有观测到的 program states 的集合的抽象的数据流值（data-flow value） 联系起来。</p></blockquote></li><li><p>Data-flow analysis is to <strong>find a solution</strong> to a set of <em><strong>safe-approximation-directed constraints</strong></em> on the IN[s]’s and OUT[s]’s, for <em>all statements s.</em></p><ul><li>constraints based on semantics of statements( transfer functions ).</li><li>constraints baesd on the flows of control.<blockquote><p>数据流分析是对所有的语句，通过解析 safe-approximation 的约束规则，得到一个 solution（给每个 program point 一个 data-flow value）。</p></blockquote></li></ul></li></ul><h2 id="2-Notations-for-Transfer-Function’s-Constraints"><a href="#2-Notations-for-Transfer-Function’s-Constraints" class="headerlink" title="2 - Notations for Transfer Function’s Constraints"></a>2 - Notations for Transfer Function’s Constraints</h2><p>Forward &amp; Backward</p><img src="/images/Data-Flow-Analysis-I/Notations-Function.png" width=480><h2 id="3-Notations-for-Control-Flow’s-Constraints"><a href="#3-Notations-for-Control-Flow’s-Constraints" class="headerlink" title="3 - Notations for Control Flow’s Constraints"></a>3 - Notations for Control Flow’s Constraints</h2><p>Control flow within a BB &amp; Control flow among BBs</p><img src="/images/Data-Flow-Analysis-I/Notations-ControlFlow.png" width=550><h1 id="Reaching-Definitions-Analysis-定义可达性分析"><a href="#Reaching-Definitions-Analysis-定义可达性分析" class="headerlink" title="Reaching Definitions Analysis( 定义可达性分析 )"></a><em>Reaching Definitions Analysis( 定义可达性分析 )</em></h1><h2 id="1-Reaching-Definitions"><a href="#1-Reaching-Definitions" class="headerlink" title="1 - Reaching Definitions"></a>1 - Reaching Definitions</h2><p>A definition d at program point p reaches a point q if there is a path from p to q such that d is not “killed” along that path.</p><img src="/images/Data-Flow-Analysis-I/Reaching-Definitions.png" width=350><blockquote><ul><li>A definition of a variable v is a statement that assigns a value to v.</li><li>Translated as: definition of variable v at program point p reaches point q if there is a path from p to q such that <em><strong>no new definition of v</strong></em> appears on that path.</li></ul></blockquote><h2 id="2-Understanding-Reaching-Definitions"><a href="#2-Understanding-Reaching-Definitions" class="headerlink" title="2 - Understanding Reaching Definitions"></a>2 - Understanding Reaching Definitions</h2><p>定义可达性可以用于侦测可能的未定义的变量。</p><p>理解定义可达性分析：</p><ul><li><p>用一个比特表示某个变量在某一点的定义可达性。</p></li><li><p>用一个 n 维比特向量表示 n 个变量在某一点的定义可达性。</p></li><li><p>Data Flow Values&#x2F;Facts</p><blockquote><p>Represented by bit vectors  </p><img src="/images/Data-Flow-Analysis-I/bit-vectors.png" width=350>  </blockquote></li><li><p>Transfer Function</p><blockquote><img src="/images/Data-Flow-Analysis-I/TF.png" width=350>  <blockquote><p>genB就是B里面的definition,killB就是其他BB里面被覆盖掉的<br>definition。</p></blockquote></blockquote></li><li><p>Control Flow</p><blockquote><img src="/images/Data-Flow-Analysis-I/CF.png" width=350></blockquote></li></ul><h2 id="3-Algorithm-of-Reaching-Definitions-Analysis"><a href="#3-Algorithm-of-Reaching-Definitions-Analysis" class="headerlink" title="3 - Algorithm of Reaching Definitions Analysis"></a>3 - Algorithm of Reaching Definitions Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithm.png" width=500><blockquote><p>在算法模板中边界条件（OUT[entry]）单独初始化。<br>对于 OUT[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top。</p></blockquote><h2 id="4-Why-this-iterative-algorithm-can-finally-stop"><a href="#4-Why-this-iterative-algorithm-can-finally-stop" class="headerlink" title="4 - Why this iterative algorithm can finally stop?"></a>4 - Why this iterative algorithm can finally stop?</h2><p>对于 Transfer Function，OUT[S] 只受 IN[S] 的影响，当个更多的 facts 流入 IN[S] 时，要么被 kill 要么存活下来并永远被保留，故 OUT[S] <strong>永远不会缩减（e.g. 0 &#x3D;&gt; 1 或 1 &#x3D;&gt; 1）</strong>，又因为定义的变量数量是有限的，故该迭代一定会停下来（实际上到达了一个不动点）</p><blockquote><p>Reach a fixed point also related with monotonicity( 单调性 )</p></blockquote><h1 id="Live-Variables-Analysis-活跃变量分析"><a href="#Live-Variables-Analysis-活跃变量分析" class="headerlink" title="Live Variables Analysis( 活跃变量分析 )"></a><em>Live Variables Analysis( 活跃变量分析 )</em></h1><h2 id="1-Live-Variables-Define"><a href="#1-Live-Variables-Define" class="headerlink" title="1 - Live Variables Define"></a>1 - Live Variables Define</h2><p>Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at P. If so, v is live at p; otherwise, v is dead at p.</p><img src="/images/Data-Flow-Analysis-I/Live-Variables.png" width=500><blockquote><p>活跃变量信息可用于寄存器分配（倾向于使用存有 dead value 的寄存器来存新数据）</p></blockquote><h2 id="2-Understanding-Live-Variables-Analysis"><a href="#2-Understanding-Live-Variables-Analysis" class="headerlink" title="2 - Understanding Live Variables Analysis"></a>2 - Understanding Live Variables Analysis</h2><p>理解活跃变量分析：</p><ul><li>用一个比特表示某个变量在某一点是否活跃</li><li>用一个 n 维比特向量表示 n 个变量在某一点是否活跃</li></ul><img src="/images/Data-Flow-Analysis-I/Unerstanding-Live-Variables.png" width=650><blockquote><p>注意use的定义为：在重定义之前被使用。</p></blockquote><h2 id="3-Alogrithm-of-Live-Variables-Analysis"><a href="#3-Alogrithm-of-Live-Variables-Analysis" class="headerlink" title="3 - Alogrithm of Live Variables Analysis"></a>3 - Alogrithm of Live Variables Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithm-LV.png" width=650><blockquote><p>在算法模板中边界条件（IN[entry]）单独初始化<br>对于 IN[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p></blockquote><h1 id="Available-Expressions-Analysis-可用表达式分析"><a href="#Available-Expressions-Analysis-可用表达式分析" class="headerlink" title="Available Expressions Analysis( 可用表达式分析 )"></a><em>Available Expressions Analysis( 可用表达式分析 )</em></h1><h2 id="1-Available-Expressions-Define"><a href="#1-Available-Expressions-Define" class="headerlink" title="1 - Available Expressions Define"></a>1 - Available Expressions Define</h2><p>An expression <strong>x op y</strong> is available at program point p if (1) all paths from th entry to p must pass through the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x or y.</p><blockquote><p>一个表达式，形如 x op y，在某个 program point p 是可用的，需要满足：</p><ul><li>从 ENTRY 到 p 的所有路径都必须计算过 x op y 的值</li><li>在这些路径各自最后一次计算该表达式的值之后没有修改过 x 或 y 的值</li></ul></blockquote><h2 id="2-Understanding-Available-Expressions-Analysis"><a href="#2-Understanding-Available-Expressions-Analysis" class="headerlink" title="2 - Understanding Available Expressions Analysis"></a>2 - Understanding Available Expressions Analysis</h2><p>理解可用表达式分析：</p><ul><li>用一个比特表示某个表达式在某点是否可用</li><li>用一个 n 维比特向量表示 n 个表达式在某点是否可用</li><li>注意这是一个 must analysis</li></ul><img src="/images/Data-Flow-Analysis-I/Understanding-AE.png" width=650><blockquote><ul><li>传递函数和控制流函数如果所示，经过一个BB块的运算，将kill掉包含被重定义过变量的表达式，并加入新的表达式。</li><li>由于是must分析，所以控制流使用meet交集。</li><li>（may分析是只要有某条路径可以就行，must分析是所有路径都要满足才行。may一般用于检测是否使用并删除未使用，must用于替换）</li><li>must分析是一种safe并且under的approximation，即允许漏报的分析。看右下角例子，按照算法其实这个错了，第二个块由于x被重定义导致OUT应该变为空集的。如果由一种特殊情况，x被重定义为和原本一样的数值，那么这个表达式仍然是可以替换的，但是为了safe，算法还是把他排除了，这就是一种漏报，成为under-approximation。</li></ul></blockquote><h2 id="3-Algorithm-of-Available-Expressions-Analysis"><a href="#3-Algorithm-of-Available-Expressions-Analysis" class="headerlink" title="3 - Algorithm of Available Expressions Analysis"></a>3 - Algorithm of Available Expressions Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithmi-AE.png" width=650><h1 id="Analysis-Comparison"><a href="#Analysis-Comparison" class="headerlink" title="Analysis Comparison"></a>Analysis Comparison</h1><img src="/images/Data-Flow-Analysis-I/Analysis-Comparison.png" width=650><h1 id="The-X-You-Need-To-Understand-in-This-Lecture"><a href="#The-X-You-Need-To-Understand-in-This-Lecture" class="headerlink" title="The X You Need To Understand in This Lecture"></a>The X You Need To Understand in This Lecture</h1><ul><li>Understand the three data flow analyses:<blockquote><p>-reaching definitions<br>-live variables<br>-available expressions</p></blockquote></li><li>Can tell the differences and similarities of the three data flow analyses</li><li>Understand the iterative algorithm and cna tell why it is able to terminate</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intermediate Representation</title>
    <link href="/2024/02/19/Intermediate-Representation/"/>
    <url>/2024/02/19/Intermediate-Representation/</url>
    
    <content type="html"><![CDATA[<h1 id="Compilers-and-Static-Analyzers"><a href="#Compilers-and-Static-Analyzers" class="headerlink" title="Compilers and Static Analyzers"></a>Compilers and Static Analyzers</h1><h2 id="1-Compiler"><a href="#1-Compiler" class="headerlink" title="1 - Compiler"></a>1 - Compiler</h2><p>Source Code -&gt; Scanner( 词法分析 ) -&gt; <em>Tokens</em> -&gt; Parser( 语法分析 ) -&gt; <em>AST</em> -&gt; Type Checker( 类型检查 ) -&gt; <em>Decorated AST</em> -&gt; Translatror -&gt; <em>IR</em> -&gt; Code Generator -&gt; Machine Code.</p><p>静态分析需要在编译器前端生成的 IR 的基础上进行代码优化。</p><h1 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h1><img src="/images/Intermediate-Representation/AST-IR.png" alt="AST vs. IR" width=550><h2 id="1-AST"><a href="#1-AST" class="headerlink" title="1 - AST"></a>1 - AST</h2><ul><li>high-level and closed to grammar structure.</li><li>usually language dependent.</li><li>suitable for fast type checking.</li><li>suitable for fast type checking.</li><li>lack of control flow information.</li></ul><h1 id="IR-Three-Address-Code-3AC"><a href="#IR-Three-Address-Code-3AC" class="headerlink" title="IR:Three-Address Code( 3AC )"></a>IR:Three-Address Code( 3AC )</h1><h2 id="1-Intermediate-Representation-IR-“3-address”-form"><a href="#1-Intermediate-Representation-IR-“3-address”-form" class="headerlink" title="1 - Intermediate Representation( IR “3-address” form )"></a>1 - Intermediate Representation( IR “3-address” form )</h2><ul><li>low-level and closed to machine code.</li><li>usually language independent.</li><li>compact and uniform.</li><li>contains control flow information.</li><li><strong>usually considered as the basis for static analysis</strong></li></ul><h2 id="2-Some-Common-3AC-Forms"><a href="#2-Some-Common-3AC-Forms" class="headerlink" title="2 - Some Common 3AC Forms"></a>2 - Some Common 3AC Forms</h2><ul><li>x &#x3D; y <em>bop</em> z</li><li>x &#x3D; <em>uop</em> y</li><li>x &#x3D; y</li><li>goto L</li><li>if x goto L</li><li>if x rop y goto L</li></ul><h1 id="3AC-in-Real-Static-Analyzer-Soot"><a href="#3AC-in-Real-Static-Analyzer-Soot" class="headerlink" title="3AC in Real Static Analyzer: Soot"></a>3AC in Real Static Analyzer: Soot</h1><h2 id="1-Some-real-world-complicated-forms"><a href="#1-Some-real-world-complicated-forms" class="headerlink" title="1 - Some real-world complicated forms"></a>1 - Some real-world complicated forms</h2><p>Java Src</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> nju.sa.examples;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class3AC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3AC(jimple)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">nju</span>.sa.examples.Class3AC <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Object<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> pi;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> &lt;init&gt;()<br>    &#123;<br>        nju.sa.examples.Class3AC r0;<br>        r0 := <span class="hljs-meta">@this</span>: nju.sa.examples.Class3AC;<br>        specialinvoke r0.&lt;java,lang.Object: <span class="hljs-keyword">void</span> &lt;init&gt;()&gt;();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span><br>    &#123;<br>        java.lang.String[] r0;<br>        r0 := <span class="hljs-meta">@parameter0</span>: java.lang.string[];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> &lt;clinit&gt;()<br>    &#123;<br>        &lt;nju.sa.examples.Class3AC: <span class="hljs-type">double</span> pi&gt; = <span class="hljs-number">3.14</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Static-Single-Assignment-SSA-–-Optional-material"><a href="#Static-Single-Assignment-SSA-–-Optional-material" class="headerlink" title="Static Single Assignment ( SSA ) – Optional material"></a>Static Single Assignment ( SSA ) – <em>Optional material</em></h1><p>All assignments in SSA are to variables with distinct names.</p><img src="/images/Intermediate-Representation/SSA.png" alt="SSA" width=400><p>Why not SSA?</p><ul><li>SSA may introduce too many variables and phi-functions.</li><li>May introduce inefficiency problem when translating to machine code (due to copy operations).</li></ul><h1 id="Basic-Blocks-BB"><a href="#Basic-Blocks-BB" class="headerlink" title="Basic Blocks( BB )"></a>Basic Blocks( BB )</h1><p>Define: Basic blocks( BB ) are maximal sequences of consecutive three-address instructions with the properties that</p><ul><li>It can be entered only at the beginning, i.e., the first instruction in the block.</li><li>It can be exited only at the end, i.e., the last instruction in the block.</li></ul><p><strong>How to build Basic Blocks?</strong></p><ul><li>Determine the leaders in P <blockquote><ul><li>The first instruciont in P is a leader.</li><li>Any target instruction of a conditional or unconditional jump is a leader.</li><li>Any instruction that immediately follows a conditional or unconditional jump is a leader.</li></ul></blockquote></li><li>Build BBs for P</li></ul><h1 id="Control-Flow-Graphs-CFG"><a href="#Control-Flow-Graphs-CFG" class="headerlink" title="Control Flow Graphs ( CFG )"></a>Control Flow Graphs ( CFG )</h1><p>How to build Control Flow Graph( CFG )</p><ul><li>The nodes of CFG are basic blocks.</li><li>There is an edge from block A to block B if and only if<blockquote><ul><li>There is a conditional or unconditional jump from the end of A to the beginning of B.</li><li>B immediately follows A in the original order of instructions <em>and A does not end in an unconditional jump</em>.</li></ul></blockquote></li><li>It is normal to replace the jumps to instruction labels by jumps to basic blocks.</li></ul><img src="/images/Intermediate-Representation/CFG.png" alt="Control Flow Graphs( CFG )" width=650><h1 id="The-X-You-Need-To-Understan-in-This-Lecture"><a href="#The-X-You-Need-To-Understan-in-This-Lecture" class="headerlink" title="The X You Need To Understan in This Lecture"></a>The X You Need To Understan in This Lecture</h1><ul><li>The relation between compilers and static analyhzers.</li><li>Understan 3AC and its common forms( in IR jimple ).</li><li>How to build basic blocks on top of IR.</li><li>How to construct control flow graphs on top of BBs?</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction</title>
    <link href="/2024/02/19/Introduction/"/>
    <url>/2024/02/19/Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h1><h2 id="1-Define"><a href="#1-Define" class="headerlink" title="1 - Define"></a>1 - Define</h2><p>静态分析通过分析程序 P 来推理其行为，并在运行 P 之前确定其是否满足某些属性。</p><blockquote><p>Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P.</p></blockquote><ul><li>Does P contain any private information leaks?</li><li>Does P dereference any null pointers?</li><li>Are all the cast operations in P safe?<br><em>- 是否存在强制类型转换异常？</em></li><li>Can v1 and v2 in P point to the same memory location?</li><li>Will certain assert staements in P fail?<br><em>- 是否存在 fail 的 assert 语句？</em></li><li>Is this piece of code in P dead(so that it could be eliminated?)<br><em>- 是否存在可以删除的死代码？</em></li></ul><h2 id="2-Rice’s-Theorem-莱斯定理"><a href="#2-Rice’s-Theorem-莱斯定理" class="headerlink" title="2 - Rice’s Theorem(莱斯定理)"></a>2 - Rice’s Theorem(莱斯定理)</h2><p>通俗的讲：不存在完美的静态分析方法(Perfect static analysis)。</p><blockquote><p>Perfect static &#x3D; Sound &amp; Complete</p></blockquote><img src="/images/Introduction/Sound-Complete.png" width=500 /><p>真正的有用的静态分析：妥协soundness或者completeness。</p><blockquote><p>Useful static analysis &#x3D; Compromise soundness OR Compromise completeness</p><blockquote><p>Compromise soundness:产生漏报( false negatives ) ( 可以接受 )<br>Compromise completeness:产生误报( false positives ) ( 不希望发生 )</p></blockquote></blockquote><h2 id="3-Static-Analysis-–Bird’s-Eye-View-整体概括"><a href="#3-Static-Analysis-–Bird’s-Eye-View-整体概括" class="headerlink" title="3 - Static Analysis –Bird’s Eye View( 整体概括 )"></a>3 - Static Analysis –Bird’s Eye View( 整体概括 )</h2><p>打破动态思维，从静态分析角度分析代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(input)<br>    x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>    x = <span class="hljs-number">0</span>;<br>-&gt; x = ?<br></code></pre></td></tr></table></figure><p>Sound: x &#x3D; 0, 1, 2, 3<br>Unsound: x &#x3D; -1, 0</p><img src="/images/Introduction/Two-Results.png" width=300 /><p><strong>Static Analysis</strong>: ensure( or get close to )<em>soundness</em>, while making good trade-offs between analysis <em>precision</em> and analysis <em>speed</em>.</p><blockquote><p>在确保 soundness 的前提下，在分析的准确度和速度之间做出有效的平衡。</p></blockquote><h1 id="Two-Words-to-Conclude-Static-Analysis"><a href="#Two-Words-to-Conclude-Static-Analysis" class="headerlink" title="Two Words to Conclude Static Analysis"></a>Two Words to Conclude Static Analysis</h1><h2 id="1-Comprehension"><a href="#1-Comprehension" class="headerlink" title="1 - Comprehension"></a>1 - Comprehension</h2><p><strong>Abstraction + Over - approximation</strong></p><blockquote><p>Abstraction（ 抽象 ）：把具体域的值映射到抽象域的值。</p></blockquote><blockquote><p>Over - approximation（ 近似 ）：在抽象层面定义转移函数；由于无法枚举所有路径，所以使用 flow merging 处理 control flow。</p></blockquote><h1 id="Focus-of-this-section"><a href="#Focus-of-this-section" class="headerlink" title="Focus of this section"></a>Focus of this section</h1><ul><li>静态分析与（动态）测试的区别？</li><li>理解 soundness, completeness, false negatives 和 false positives 的概念</li><li>为什么静态分析需要保证 soundness？</li><li>怎样理解 abstraction 和 over-approximation？</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning Markdown~</title>
    <link href="/2024/02/19/Learning-Markdown/"/>
    <url>/2024/02/19/Learning-Markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Markdonw"><a href="#一、Markdonw" class="headerlink" title="一、Markdonw"></a>一、Markdonw</h2><p>一款轻量级标记语言。</p><h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h3><blockquote><p>这是一段引用。</p></blockquote><h3 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>把大象放进冰箱：</p><ol><li>打开冰箱。</li><li>把大象塞进冰箱。</li><li>关上冰箱。</li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>Markdown</li><li>is</li><li>very</li><li>nice</li></ul><h3 id="Todo："><a href="#Todo：" class="headerlink" title="Todo："></a>Todo：</h3><ul><li><input disabled="" type="checkbox"> sleep</li><li><input checked="" disabled="" type="checkbox"> eat</li></ul><h3 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h3><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">16</td><td align="center">89</td></tr><tr><td align="left">李四</td><td align="right">17</td><td align="center">90</td></tr><tr><td align="left">王五</td><td align="right">17</td><td align="center">95</td></tr></tbody></table><h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p><a href="github.com" title="代码开源网站">GitHub</a><br><a href="github.com" title="代码开源网站">github</a></p><h3 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h3><p><em>斜体</em>,加粗,<code>printf()</code>,:smile:,H<del>2</del>O,X^2^,&#x3D;&#x3D;高亮文字&#x3D;&#x3D;</p><h3 id="嵌入式代码："><a href="#嵌入式代码：" class="headerlink" title="嵌入式代码："></a>嵌入式代码：</h3><iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guangyuan Bacchus Garden Lantern Festival</title>
    <link href="/2024/02/18/%E5%B9%BF%E5%85%83%E7%99%BE%E8%8D%89%E5%9B%AD%E7%81%AF%E4%BC%9A/"/>
    <url>/2024/02/18/%E5%B9%BF%E5%85%83%E7%99%BE%E8%8D%89%E5%9B%AD%E7%81%AF%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<img src="/images/广元百草园灯会/1.jpg"  /><img src="/images/广元百草园灯会/2.jpg"  /><img src="/images/广元百草园灯会/3.jpg"  /><img src="/images/广元百草园灯会/4.jpg"  /><img src="/images/广元百草园灯会/5.jpg"  /><img src="/images/广元百草园灯会/6.jpg"  /><img src="/images/广元百草园灯会/7.jpg"  /><img src="/images/广元百草园灯会/8.jpg"  /><img src="/images/广元百草园灯会/9.jpg"  /><img src="/images/广元百草园灯会/10.jpg"  /><img src="/images/广元百草园灯会/11.jpg"  /><img src="/images/广元百草园灯会/12.jpg"  /><img src="/images/广元百草园灯会/13.jpg"  />]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lantern Festival</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/15/hello-world/"/>
    <url>/2024/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
