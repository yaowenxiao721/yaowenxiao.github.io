<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Compliers-Week2</title>
    <link href="/2024/03/13/Compliers-Week2/"/>
    <url>/2024/03/13/Compliers-Week2/</url>
    
    <content type="html"><![CDATA[<h1 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (i == j)<br>    z = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span><br>    z =<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><blockquote><p>\tif (i &#x3D;&#x3D; j)\n\t\tz &#x3D; 0;\n\telse\n\t\tz&#x3D; 1;</p></blockquote><ul><li>Token Class (or Class)<br>-In English: Noun, verb, adj<br>-In a programming language: Identifier, Keywords, ‘(‘, ‘)’, Numbers …</li></ul><p>Token 的类别：</p><ul><li>Identifier:<br>-strings of letters or digits, starting with a letter.</li><li>Integer:<br>-a non-empty string of digits.</li><li>Keyword:<br>-“else” or “if” or “begin” or …</li><li>Whitespace:<br>-a non-empty sequene of blanks, newlines, and tabs.</li></ul><p><strong>A Lexical Analysis implementation must do two things:</strong></p><ol><li>Recognize substrings corresponding to tokens.</li><li>Identify the token class of each Iexeme.</li></ol><h2 id="Lexical-Analysis-Examples"><a href="#Lexical-Analysis-Examples" class="headerlink" title="Lexical Analysis Examples"></a>Lexical Analysis Examples</h2><p><strong>LA Examples - lookhead</strong></p><blockquote><p>DO 5 I &#x3D; 1, 25<br>DO 5 I &#x3D; 1.25 -&gt; DO5I &#x3D; 1.25</p></blockquote><ol><li>The goal is to partition the string. This is implemented by reading left-to-right, recognizing one token at a time.</li><li>“Lookahead” may be required to decide where one token ends and the next token begins.<blockquote><p>设计 lexical 规则时，很重要的 goal 之一就是，尽可能少的 lookahead,<br>Fortran 里面，空格是没有意义的，在这个例子中就需要 lookahead 来理解语句的真实意图。</p></blockquote></li></ol><p><strong>LA Examples C++</strong></p><ul><li>C++ template syntax: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">FOO&lt;Bar&gt;<br></code></pre></td></tr></table></figure></li><li>C++ stream syntax: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">cin &gt;&gt; var<br></code></pre></td></tr></table></figure><blockquote><p>下面这条语句会使这两个混淆</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">Foo&lt;Bar&lt;Bazz&gt;&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong>Summarize</strong></p><ul><li>The goal of lexical analysis is to<br>-Partition the input string into lexemes<br>-Identify the token of each lexeme</li><li>Left-to-right scan &#x3D;&gt; lookahead sometimes required.</li></ul>]]></content>
    
    
    <categories>
      
      <category>Compilers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS143</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Compliers-Week1</title>
    <link href="/2024/03/12/Compliers-Week1/"/>
    <url>/2024/03/12/Compliers-Week1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-1-Introduction"><a href="#1-1-Introduction" class="headerlink" title="1.1 - Introduction"></a>1.1 - Introduction</h1><h2 id="Programming-Languages"><a href="#Programming-Languages" class="headerlink" title="Programming Languages"></a>Programming Languages</h2><ul><li>Compliers<blockquote><p>Program –&gt; C (off-line) –&gt; exec<br>Data –&gt; exec –&gt; Output</p></blockquote></li><li>Interpreters<blockquote><p>Program &amp; Data –&gt; I (on-line)–&gt; Output</p></blockquote></li></ul><h2 id="FORTRAN-I"><a href="#FORTRAN-I" class="headerlink" title="FORTRAN I"></a>FORTRAN I</h2><ol><li>Lexical Analysis</li><li>Parsing<blockquote><p>Syntactic</p></blockquote></li><li>Semantic Analysis<blockquote><p>Types &amp; scope rules</p></blockquote></li><li>Optmization</li><li>Code Generation<blockquote><p>Translation</p></blockquote></li></ol><h1 id="1-2-Structure-of-a-Compiler"><a href="#1-2-Structure-of-a-Compiler" class="headerlink" title="1.2 - Structure of a Compiler"></a>1.2 - Structure of a Compiler</h1><p><strong>Lexical analysis</strong></p><p>Lexical analysis: divides program text into “words” or “tokens”</p><blockquote><p>if x &#x3D;&#x3D; y then z &#x3D; 1; else z &#x3D; 2;</p></blockquote><p><strong>Parsing</strong></p><ul><li><p>Once words are understood, the next step is to understand sentence structure.</p></li><li><p>Parsing &#x3D; Diagramming Sentences<br>-The diagram is a tree</p></li></ul><p><strong>Semantic Analysis</strong></p><ul><li><p>Once sentence structure is understood, we can try to understand “meaning”.</p></li><li><p>Programming languages define strict rules to avoid ambiguities.</p></li></ul><p><strong>Optmization</strong></p><ul><li>Automatically modify programs so that they<br>-Run faster<br>-Use less memory<br>-Power<br>-Network<br>-Database</li></ul><p><strong>Code Generation</strong></p><ul><li>A translation into another language<br>-Analogous to human translation</li></ul><h1 id="1-3-The-Economy-of-Programming-Languages"><a href="#1-3-The-Economy-of-Programming-Languages" class="headerlink" title="1.3 - The Economy of Programming Languages"></a>1.3 - The Economy of Programming Languages</h1><ul><li><p>Why are there so many programming languages?<br>没有一种程序语言可以适用于所有的场景需求。</p></li><li><p>Why are there new programming languages?</p></li></ul><ol><li>Widely used languages are slow to change.</li><li>Easy to start a new language.</li></ol><ul><li>What is a good programming language?</li></ul><p>There is no universally accepted metric for language design.</p><h1 id="2-1-Cool-Overview"><a href="#2-1-Cool-Overview" class="headerlink" title="2.1 - Cool Overview"></a>2.1 - Cool Overview</h1><h1 id="2-2-cool-example-II"><a href="#2-2-cool-example-II" class="headerlink" title="2.2 - cool example II"></a>2.2 - cool example II</h1><h1 id="2-3-cool-example-III"><a href="#2-3-cool-example-III" class="headerlink" title="2.3 - cool example III"></a>2.3 - cool example III</h1>]]></content>
    
    
    <categories>
      
      <category>Compilers</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CS143</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pointer-Analysis</title>
    <link href="/2024/03/07/Pointer-Analysis/"/>
    <url>/2024/03/07/Pointer-Analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="Pointer-Analysis"><a href="#Pointer-Analysis" class="headerlink" title="Pointer Analysis"></a>Pointer Analysis</h1><h2 id="1-Introduction-to-Pointer-Analysis"><a href="#1-Introduction-to-Pointer-Analysis" class="headerlink" title="1 - Introduction to Pointer Analysis"></a>1 - Introduction to Pointer Analysis</h2><h3 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h3><ul><li>A fundamental static analysis: 计算一个指针能指向哪个内存位置。</li><li>For object-oriented programs (focus on Java): 计算一个一个指针(variable或field)指向哪个对象。</li><li>Regarded as a may-analysis: 计算指针指向的过拟合的对象集，即一个指针可能指向哪些对象</li></ul><h3 id="Pointer-Analysis-and-Alias-Analysis"><a href="#Pointer-Analysis-and-Alias-Analysis" class="headerlink" title="Pointer Analysis and Alias Analysis"></a>Pointer Analysis and Alias Analysis</h3><p><strong>Two closely related but different concepts</strong><br>e.g.<br>If two pointers, say p and q, refer to the same object, then p and q are aliases.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br>q = p;<br>x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">X</span>();<br>y = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Y</span>();<br></code></pre></td></tr></table></figure><blockquote><p>p and q are aliases x and y are not aliases.</p></blockquote><h3 id="Applications-of-Pointer-Analysis"><a href="#Applications-of-Pointer-Analysis" class="headerlink" title="Applications of Pointer Analysis"></a>Applications of Pointer Analysis</h3><ul><li>Call graph, aliases, …</li><li>Virtual call inlining, …</li><li>Null pointer detection, …</li><li>Information flow analysis, …</li></ul><h2 id="2-Key-Factors-of-Pointer-Analysis"><a href="#2-Key-Factors-of-Pointer-Analysis" class="headerlink" title="2 - Key Factors of Pointer Analysis"></a>2 - Key Factors of Pointer Analysis</h2><p>Pointer analysis is a complex system, multiple factors affect the precision and efficiency of the system.</p><ul><li>Heap abstraction</li><li>Context sensitivity</li><li>Flow sensitivity</li><li>Analysis scope</li></ul><h3 id="Heap-Abstraction"><a href="#Heap-Abstraction" class="headerlink" title="Heap Abstraction"></a>Heap Abstraction</h3><img src="/images/Pointer-Analysis/Heap-Abstration.png" width=500><p><strong>Allocation-Site Abstraction</strong><br>e.g.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>    a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>对于这样的一个 for 循环创建对象，使用 Allocation-Site 分析的话，就只抽象为一个对象。</p></blockquote><h3 id="Context-Sensitivity-Context-insensitive"><a href="#Context-Sensitivity-Context-insensitive" class="headerlink" title="Context Sensitivity &amp; Context-insensitive"></a>Context Sensitivity &amp; Context-insensitive</h3><img src="/images/Pointer-Analysis/Context-Sensitivity.png" width=500><blockquote><p>左侧是上下文敏感的做法，对于每次调用方法的时候都会分别记录那次方法的上下文信息，而右侧是不敏感的做法，会将不同的调用合并，每个方法不论调用多少次都只会分析一次，Context-sensitive 对于指针分析的精度有非常显著的作用。</p></blockquote><h3 id="Flow-Sensitivity-Flow-Insensitive"><a href="#Flow-Sensitivity-Flow-Insensitive" class="headerlink" title="Flow Sensitivity &amp; Flow Insensitive"></a>Flow Sensitivity &amp; Flow Insensitive</h3><p>flow -&gt; control-flow</p><img src="/images/Pointer-Analysis/Flow-Sensitivity.png" width=500><blockquote><p>Flow-insensitive 就是忽略了控制流消息，表层来看的话就是去并集涵盖所有情况。<br>并没有证据表明 Flow-sensitive 的效果会比 Flow-insensitive 的效果好，所以主流的一些分析器是用的 Flow-insensitive。</p></blockquote><h3 id="Analysis-Scope-Whole-pragram-Demand-driven"><a href="#Analysis-Scope-Whole-pragram-Demand-driven" class="headerlink" title="Analysis Scope - Whole-pragram &amp; Demand-driven"></a>Analysis Scope - Whole-pragram &amp; Demand-driven</h3><img src="/images/Pointer-Analysis/Analysis-Scope.png" width=500><blockquote><p>所谓需求驱动的分析，例如要分析第五行的指针指向何处，只需要分析第四行即可。</p></blockquote><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><table><thead><tr><th align="left">Factor</th><th align="left">Problem</th><th align="left">Choice</th></tr></thead><tbody><tr><td align="left">Heap abstraction</td><td align="left">How to model heap memory?</td><td align="left">Allocation-site</td></tr><tr><td align="left">Context sensitivity</td><td align="left">How to model calling contexts?</td><td align="left">Context-sensitive &amp; Context-insensitive</td></tr><tr><td align="left">Flow sensitivity</td><td align="left">How to model control flow?</td><td align="left">flow-insensitive</td></tr><tr><td align="left">Analysis scope</td><td align="left">which parts of program should be analyzed?</td><td align="left">whole-program</td></tr></tbody></table><h2 id="3-Concerned-Statements"><a href="#3-Concerned-Statements" class="headerlink" title="3 - Concerned Statements"></a>3 - Concerned Statements</h2><p>Pointer analysis only focus on pointer-affecting statements.</p><p>Pointer in Java</p><ul><li><strong>Local variable: x</strong></li><li>Static field: C.f (Sometimes referred as global variable)</li><li><strong>Instance field: x.f</strong></li><li>Array element: array[i] (Ignore indexes)</li></ul><p>Real code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br>array[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;x&quot;</span>;<br>array[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;y&quot;</span>;<br>s = array[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>Perspective of pointer analysis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[];<br>array.arr = <span class="hljs-string">&quot;x&quot;</span>;<br>array.arr = <span class="hljs-string">&quot;y&quot;</span>;<br>s = array.arr;<br></code></pre></td></tr></table></figure><h3 id="Pointer-Affecting-Statements"><a href="#Pointer-Affecting-Statements" class="headerlink" title="Pointer-Affecting Statements"></a>Pointer-Affecting Statements</h3><ul><li>New: x &#x3D; new T()</li><li>Assign: x &#x3D; y</li><li>Store: x.f &#x3D; y</li><li>Load: y &#x3D; x.f<blockquote><p>First focus on these statements</p></blockquote></li><li>Call: r &#x3D; x.k(a, …)</li></ul><h1 id="Pointer-Analysis-Foundations-I"><a href="#Pointer-Analysis-Foundations-I" class="headerlink" title="Pointer Analysis Foundations (I)"></a>Pointer Analysis Foundations (I)</h1><h2 id="1-Pointer-Analysis-Rules"><a href="#1-Pointer-Analysis-Rules" class="headerlink" title="1 - Pointer Analysis: Rules"></a>1 - Pointer Analysis: Rules</h2><img src="/images/Pointer-Analysis/domains-notations.png" width=500><blockquote><p>Points-to relations: 指向关系</p></blockquote><img src="/images/Pointer-Analysis/Rules.png" width=500><ol><li>New语句负责新建对象实例，由于等号右边没有对应指针域，所以就没有前提条件，所以直接得到等号左侧的指针对象x对应的指针集为oi，表示为 𝑜𝑖 ∈ 𝑝𝑡(𝑥)。<br>此处的 𝑜𝑖 ∈ 𝑝𝑡(𝑥) 代表 𝑜𝑖 是 𝑝𝑡(𝑥) 的子集，即 𝑜𝑖 是 x 的指针集的子集，也可以简单理解为 x 指向 oi。</li><li>assign 语句即将等号右侧的指针域传递给等号左侧</li><li>store 语句是将指针存储到对象的域中的操作，将等号右侧指针域传递给左侧对象的域的指针集中。</li><li>load 语句类似于 store 语句，将等号右侧的对象的域的指针集的数据加载到等号左侧的 y 中。</li></ol><h2 id="2-How-to-Implement-Pointer-Analysis"><a href="#2-How-to-Implement-Pointer-Analysis" class="headerlink" title="2 - How to Implement Pointer Analysis"></a>2 - How to Implement Pointer Analysis</h2><p>使用图的方式来解决传播指针集的问题。</p><h3 id="Pointer-Flow-Graph-PFG"><a href="#Pointer-Flow-Graph-PFG" class="headerlink" title="Pointer Flow Graph (PFG)"></a>Pointer Flow Graph (PFG)</h3><p><strong>Define:</strong></p><p>Pointer flow graph of a program is a directed graph that expresses how objects flow among th pointers in the program.</p><ul><li>Nodes: Pointer &#x3D; V U (O x F)<blockquote><p>A node n represents a variable or a field of ana abstract object</p></blockquote></li><li>Edges: Pointer x Pointer<blockquote><p>An edge x -&gt; y means that the objects pointed by pointer x may flow to (and also be pointed to by) pointer y.</p></blockquote></li></ul><p><strong>Pointer Flow Graph: An Example</strong></p><img src="/images/Pointer-Analysis/PFG-EP.png" width=500><blockquote><p>此程序有个前提假设，就是c和d都指向oi（c指向oi说明oi肯定在c的指针集中，但是c的指针集中可能还有别的），也就是说二者是利用同一个类创建的对象。第一句和第二句可以画出两条边，代表b流向a，a流向 c.f 即 oi.f ；同理第三句第四句可以划出下面的两条边，代表c流向d，d流向 c.f 即 oi.f ；第五句代表 d.f 流向e，又因为前提条件中c和d都指向oi，所以得到第五条边。<br>由上述过程，可以总结出指针分析主要有两个过程，一是画指针流图，二是在指针流图中更新指向信息，这两个过程交互着动态进行的。例如在画第五条边的时候就需要前面的指向信息才能画出。</p></blockquote><h2 id="3-Pointer-Analysis-Algorithms"><a href="#3-Pointer-Analysis-Algorithms" class="headerlink" title="3 - Pointer Analysis: Algorithms"></a>3 - Pointer Analysis: Algorithms</h2><img src="/images/Pointer-Analysis/Pointer-Analysis-Algorithms.png" width=500><p>左边部分为main algorithm (主算法)</p><ul><li>S: 输入程序中的语句</li><li>WL: work list，需要处理的指向信息</li><li>PFG: 指针流图</li></ul><h3 id="Main-Algorithm"><a href="#Main-Algorithm" class="headerlink" title="Main Algorithm"></a>Main Algorithm</h3><p><strong>初始化算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Solve(S)<br>    WL=[], PFG=&#123;&#125;<br>    foreach i: x = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>() ∈ S <span class="hljs-keyword">do</span><br>        add &lt;x, &#123;oi&#125;&gt; to WL<br>    <span class="hljs-type">foreach</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> y ∈ S <span class="hljs-keyword">do</span><br>        <span class="hljs-title function_">AddEdge</span><span class="hljs-params">(y, x)</span><br></code></pre></td></tr></table></figure><p>检测所有语句中的 New 语句，将指针与对应的域绑定传入WL中</p><p><strong>AddEdge 方法明细</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">AddEdge(s, t)<br>    <span class="hljs-keyword">if</span> s -&gt; t ∉ PFG then<br>        add s -&gt; t to PFG<br>        <span class="hljs-keyword">if</span> <span class="hljs-title function_">pt</span><span class="hljs-params">(s)</span> is not empty then <br>            add&lt;t,pt(s)&gt; to WL<br></code></pre></td></tr></table></figure><p>首先判断从s流向t的边是否已经在PFG中存在，如果存在就什么是都不干，如果不存在就进行下一步。如果不存在首先将其加入，然后判断源点s的指针域是否为空，只要不为空，就将其与目标点构成对加入WL中，以确保s指向的指针域一定会传递给t。</p><p><strong>差分传播</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> WL is not empty <span class="hljs-keyword">do</span><br>    remove &lt;n, pts&gt; from WL<br>    ∆ = pts - pt(n)<br>    Propagate(n, ∆)<br></code></pre></td></tr></table></figure><img src="/images/Pointer-Analysis/cf.png" width=250><p>先从WL中按照某种规则取出一个对，取pts和pt(n)的差集，即去除pts中所有存在于n指针域中的指向信息，得到Δ，再对n和Δ做一个 Propagate传播操作：</p><p><strong>Propagate 方法明细</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Propagate(n, pts)<br>    <span class="hljs-keyword">if</span> pts is not empty then<br>        <span class="hljs-title function_">pt</span><span class="hljs-params">(n)</span> U= pts<br>        foreach n -&gt; s ∈ PFG <span class="hljs-keyword">do</span> <br>            add&lt;s, pts&gt; to WL<br></code></pre></td></tr></table></figure><p>传播函数做两件事，将传入的指针域pts与操作加入n的指针域，然后将其与n的所有后继构成对加入 WL 中。结合之前的 Δ，可以理解为，将n缺少的指向信息加入n的指针域中，然后将这变化部分传播给 n 的后继。<br>其中之所以做差分，也是为了进行去重，减少系统开支。算法中 pt(n) ⋃&#x3D; pts 也是整个算法里唯一一处改变指针集的地方。</p><p><strong>Store and Load</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> n represents a variable x then<br>    foreach oi ∈ Δ <span class="hljs-keyword">do</span><br>        foreach x.f = y ∈ S <span class="hljs-keyword">do</span><br>            <span class="hljs-title function_">AddEdge</span><span class="hljs-params">(y, oi.f)</span><br>        <span class="hljs-type">foreach</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x.f ∈ S <span class="hljs-keyword">do</span><br>            <span class="hljs-title function_">AddEdge</span><span class="hljs-params">(oi.f, y)</span><br></code></pre></td></tr></table></figure><h2 id="4-Pointer-Analysis-with-Method-Calls"><a href="#4-Pointer-Analysis-with-Method-Calls" class="headerlink" title="4 - Pointer Analysis with Method Calls"></a>4 - Pointer Analysis with Method Calls</h2>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interprocedural-Analysis</title>
    <link href="/2024/03/07/Interprocedural-Analysis/"/>
    <url>/2024/03/07/Interprocedural-Analysis/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Call-Graph-Construction-程序调用图"><a href="#1-Call-Graph-Construction-程序调用图" class="headerlink" title="1 - Call Graph Construction 程序调用图"></a>1 - Call Graph Construction 程序调用图</h1><h2 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h2><p>A representation of calling relationships in the program</p><ul><li>Essentially, a call graph is a set of call edges from call-sites to their target methods (calles)</li></ul><p><strong>OO 语言的调用图的构造</strong></p><ul><li>Class hierarchy analysis (CHA) : 效率高</li><li>Pointer analysis (k-CFA) : 精确度高</li></ul><h2 id="Method-Calls-Invocations-in-Java"><a href="#Method-Calls-Invocations-in-Java" class="headerlink" title="Method Calls (Invocations) in Java"></a>Method Calls (Invocations) in Java</h2><img src="/images/Interprocedural-Analysis/Method-Call.png" width=500><blockquote><p>JAVA 中的方法调用共有五种，其中 invokedynamic 在此不做考虑，由于 Virtual Call 的目标方法是运行时动态确定的（多态），故构造调用图的难点和关键在于如何处理 Virtual Call</p></blockquote><p><strong>Method Dispatch of Virtual Calls</strong></p><p>During run-time, a virtual call is resolved based on</p><ol><li>type of the receiver object (pointed by 0): c</li><li>method signature at the call site: m</li></ol><p>We define function Dispatch(c,m) to simulate the procedure of run-time method dispatch</p><img src="/images/Interprocedural-Analysis/dispatch.png" width=500><blockquote><p>Virtual Call 的方法分派依据 receiver object 的类型 c 和方法的签名 m （形如 *&lt;ClassType：ReturnType MehtodName（ParameterTypes）&gt;*），定义函数 Dispatch(c, m) 去模拟运行时方法分派，总的思路是优先在子类中匹配，匹配不到则递归地到父类中匹配</p></blockquote><h2 id="Class-Hierarchy-Analysis-CHA"><a href="#Class-Hierarchy-Analysis-CHA" class="headerlink" title="Class Hierarchy Analysis* (CHA)"></a>Class Hierarchy Analysis* (CHA)</h2><ul><li>Require the class hierarchy information (inheritance structure) of the whole program.</li><li>Resolve a virtual call based on the declared type of receiver variable of the call site.</li><li>Assume the receiver variable a may point to objects of class A or all subclassses of A.</li><li>Resolve target methods by looking up the class hierarchy of class A.</li></ul><p><strong>Call Resolution of CHA</strong></p><img src="/images/Interprocedural-Analysis/Call-Solution-of-CHA.png" width=500><ul><li><p>static call</p><blockquote><p>static call，可以简单翻译为静态调用，主要用于静态调用方法，如图所示，直接用类C调用方法而不需要定义对象c，因此很明显调用的就是当前类的方法，所以直接加到集合T中。</p></blockquote></li><li><p>special call</p><blockquote><p>special call，特殊调用，主要分为三种情况，这是第一种使用 super 类的调用方法那么这个 foo() 虽然在当前类有定义，但是实际使用的是父类的 foo() ，因此需要使用 Dispatch 函数，其中的 foo() 的签名 m 由编译器返回信息可以知道是 B 的，那么获取 foo() 返回值的 c 也指向 B，也就相当于在父类中寻找了。</p></blockquote></li></ul><blockquote><p>special call 中的另外两种情况，构造函数和私有函数，其中构造函数暂时可以忽略，所以先看私有函数，此时编译器返回的信息能算法知道此时 m 指向的仍是 C，那么 Dispatch(cm,m) 得到的仍然是这个私有方法 C.bar()。</p></blockquote><ul><li>virtual call<blockquote><p>virtual call，这也是 CHA 区别于其他算法的主要之处。除了以上提到的四种情况以外，其他情况都是用 virtual call 来处理，因为除了 super 会将 m 的类类型指定为父类以外，别的都是当前类，所以该算法会对此方法做一个 Dispatch(c,m) 并将 c 的所有子集以及子集的子集全都做一次 Dispatch(c’,m)。直观来看，可以分为两步，第一步是对本身做一次 Dispatch ，看看当前类中是否有 foo() ，没有的话就到父类中递归地找；第二步是在当前类地所有子集中找到所有的 foo() ，然后将这些 foo 同第一步找到的 foo 全都加入 T 中。</p></blockquote></li></ul><p><em>example</em></p><img src="/images/Interprocedural-Analysis/CHA-Example.png" width=500><p>Features of CHA</p><ul><li>Advantage: fast</li><li>Disadvantage: imprecise</li></ul><h2 id="Call-Graph-Construction"><a href="#Call-Graph-Construction" class="headerlink" title="Call Graph Construction"></a>Call Graph Construction</h2><p><strong>Call Graph Construction: Algorithm</strong></p><img src="/images/Interprocedural-Analysis/algorithm.png" width=500><ul><li>WL: Work list, containing the methods to be processed</li><li>CG: Call graph, aset of call edges</li><li>RM: A set of reachable methods</li></ul><h2 id="Interprocedural-Control-Flow-Graph"><a href="#Interprocedural-Control-Flow-Graph" class="headerlink" title="Interprocedural Control-Flow Graph"></a>Interprocedural Control-Flow Graph</h2><p><strong>CFG vs. ICFG</strong></p><ul><li>CFG represents structure of an individual method.</li><li>ICFG represents structure of the whole program.</li><li>An ICFG of a program consists of CFGs of the methods in the program, <em>plus two kinds of additional edges</em>:<blockquote><ul><li><strong>Call edges</strong>: from call sites to the entry nodes of their callees.</li><li><strong>Return edges</strong>: from return statements of the callees to the statements following their call sites.</li></ul></blockquote></li></ul><img src="/images/Interprocedural-Analysis/CFG-ICFG.png" width=300><h2 id="Interprocedural-Data-Flow-Analysis"><a href="#Interprocedural-Data-Flow-Analysis" class="headerlink" title="Interprocedural Data-Flow Analysis"></a>Interprocedural Data-Flow Analysis</h2><img src="/images/Interprocedural-Analysis/Iterprocedural-Analysis.png" width=500><ul><li>Call edge transfer: pass argument values</li><li>Return edge transfer: pass return values</li><li>Node transfer: same as intra-procedural constant propagation, plus that: for each call node, kill data-flow value for the LHS variable. Its value will flow to return site along the return edges.<blockquote><p>调用边传递函数，用于传递参数值<br>返回边传递函数，用于传递返回值<br>Node transfer：与前面文章提到的传递函数基本一样，但是多了一个性质，对于每次调用(例如b&#x3D;foo(a))会将等式左侧的数值kill掉，然后在下一步中有返回边传递函数重新赋值。这个操作可以在返回值与原值不同时防止数据冲突。</p></blockquote></li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The-Logic-Of-OpenStack</title>
    <link href="/2024/03/06/The-Logic-Of-OpenStack/"/>
    <url>/2024/03/06/The-Logic-Of-OpenStack/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenStack-RPC-大致流程"><a href="#OpenStack-RPC-大致流程" class="headerlink" title="OpenStack RPC 大致流程"></a>OpenStack RPC 大致流程</h1><p>RPC Client -&gt; AMQP(消息通信介质) -&gt; RPC Server</p><p>RPC Client</p><ul><li>1 - cctxt&#x3D;<strong>self.client</strong>.prepare(…) - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;client.py</li><li>2 - cctxt.call()&#x2F;cctxt.cast() - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;client.py</li></ul><p>RPC Server</p><ul><li>3 - <strong>get_rpc_server</strong>() - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;server.py</li></ul><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><h1 id="OpenStack-RPC-具体实现过程、实现函数分析"><a href="#OpenStack-RPC-具体实现过程、实现函数分析" class="headerlink" title="OpenStack RPC 具体实现过程、实现函数分析"></a>OpenStack RPC 具体实现过程、实现函数分析</h1><p>OpenStack 中定义了两种 RPC 调用接口 rpc.call、rpc.cast</p><blockquote><ul><li>rpc.call 方式是指 request&#x2F;response（请求&#x2F;响应）模式，即客户端在发送请求后，继续等待服务器端的响应结果，待响应结果到达后，才结束整个过程。</li><li>rpc.cast 方式是指客户端发送RPC调用请求后，不等待服务器端的响应结果。</li></ul></blockquote><p>上层实现函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># prepare()</span><br>cctxt=self.client.prepare(...)<br><span class="hljs-comment"># call() or cast()</span><br>cctxt.cast(ctxt, <span class="hljs-string">&#x27;method&#x27;</span>, **kw) /<br>cctxt.call(ctxt, <span class="hljs-string">&#x27;method&#x27;</span>, **kw)<br></code></pre></td></tr></table></figure><h2 id="1-cctxt-self-client-prepare-…-oslo-messaging-oslo-messaging-rpc-client-py"><a href="#1-cctxt-self-client-prepare-…-oslo-messaging-oslo-messaging-rpc-client-py" class="headerlink" title="1 - cctxt&#x3D;self.client.prepare(…) - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;client.py"></a>1 - cctxt&#x3D;self.client.prepare(…) - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;client.py</h2><h3 id="prepare方法"><a href="#prepare方法" class="headerlink" title="prepare方法"></a>prepare方法</h3><p>prepare方法总是出现在call()&#x2F;cast()方法之前，完成rpc调用前消息的准备工作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">prepare</span>(<span class="hljs-params">self, exchange=_marker, topic=_marker, namespace=_marker,</span><br><span class="hljs-params">            version=_marker, server=_marker, fanout=_marker,</span><br><span class="hljs-params">            timeout=_marker, version_cap=_marker, retry=_marker,</span><br><span class="hljs-params">            call_monitor_timeout=_marker</span>):<br>    <span class="hljs-keyword">return</span> _CallContext._prepare(self,<br>                                 exchange, topic, namespace,<br>                                 version, server, fanout,<br>                                 timeout, version_cap, retry,<br>                                 call_monitor_timeout)<br></code></pre></td></tr></table></figure><blockquote><p>这个方法主要做了以下几件事:</p><ul><li>从调用参数 (topic、server等) 和客户端配置中构建一个 oslo_messaging.Target 对象,用于表示 RPC 调用的目标主题、服务器等信息。</li><li>获取 Transport 使用的 Serializer 对象,用于序列化&#x2F;反序列化消息。</li><li>创建并返回一个_CallContext对象,它封装了 Transport、Target 和 Serializer 等信息,作为后续 RPC 调用的上下文。</li></ul></blockquote><p>_CallContext对象定义在同一个文件中,它提供了 call、cast 等方法,用于真正发起同步或异步的RPC调用。<br>所以 prepare 方法的作用是准备 RPC 调用所需的上下文,为后续的 call 或 cast 调用做好基础工作。在代码 cctxt &#x3D; self.client.prepare(…) 中,返回的 cctxt 就是一个 _CallContext 实例,包含了调用目标、序列化器等重要信息。</p><h3 id="调用prepare的对象self-client"><a href="#调用prepare的对象self-client" class="headerlink" title="调用prepare的对象self.client"></a>调用prepare的对象self.client</h3><p>eg.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">super</span>(SchedulerAPI, self).__init__()<br>    target = messaging.Target(topic=RPC_TOPIC, version=<span class="hljs-string">&#x27;4.0&#x27;</span>)<br>    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.scheduler,<br>                                           CONF.upgrade_levels.scheduler)<br>    serializer = objects_base.NovaObjectSerializer()<br>    self.client = rpc.get_client(target, version_cap=version_cap,<br>                                 serializer=serializer)<br></code></pre></td></tr></table></figure><p>关注两条语句</p><ul><li>target &#x3D; messaging.Target(topic&#x3D;RPC_TOPIC, version&#x3D;’4.0’)</li><li>self.client &#x3D; rpc.get_client(target, version_cap&#x3D;version_cap,<br>                               serializer&#x3D;serializer)</li></ul><p><strong>Target</strong></p><p>Target 对象代表一个调用需要匹配的目标。RPC client 端需要指定 Target 来进行 RPC 调用，RPC server 端也要指定 Target 来说明接收哪些 RPC 调用。Target 在底层被用来决定 RPC server 需要创建哪些队列，使用哪些 routing key 来绑定到 exchange 上，以及 RPC client 发送消息的 <em>routing key</em>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Target</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, exchange=<span class="hljs-literal">None</span>, topic=<span class="hljs-literal">None</span>, namespace=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                 version=<span class="hljs-literal">None</span>, server=<span class="hljs-literal">None</span>, fanout=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                 legacy_namespaces=<span class="hljs-literal">None</span></span>):<br>        self.exchange = exchange<br>        self.topic = topic<br>        self.namespace = namespace<br>        self.version = version<br>        self.server = server<br>        self.fanout = fanout<br>        self.accepted_namespaces = [namespace] + (legacy_namespaces <span class="hljs-keyword">or</span> [])<br></code></pre></td></tr></table></figure><p>例如：在代码 target &#x3D; messaging.Target(topic&#x3D;RPC_TOPIC, version&#x3D;’4.0’) 中，指定了消息发往的服务器是监听 ‘RPC_TOPIC’ topic 的 version&#x3D;’4.0’ 服务器。</p><p><strong>rpc.get_client()</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_client</span>(<span class="hljs-params">target, version_cap=<span class="hljs-literal">None</span>, serializer=<span class="hljs-literal">None</span>, transport=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Get a client for rpc communication.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param target: The target to call.</span><br><span class="hljs-string">        (target := node-name queues first, then server name)</span><br><span class="hljs-string">    :param version_cap: A version cap object</span><br><span class="hljs-string">    :param serializer: Optional, otherwise RPCTransport&#x27;s &#x27;allowed_rpc_message_serializers&#x27;</span><br><span class="hljs-string">         config option is used.</span><br><span class="hljs-string">    :param transport: Optional transport for transport driver</span><br><span class="hljs-string">    :returns: A client for issuing RPC calls.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> transport <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        transport = _get_rpc_transport()<br><br>    <span class="hljs-keyword">if</span> serializer <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        serializer = transport._serializer<br><br>    <span class="hljs-keyword">return</span> RPCClient(transport, target, name=<span class="hljs-literal">None</span>,<br>                     version_cap=version_cap,<br>                     serializer=serializer)<br></code></pre></td></tr></table></figure><p>这个方法接受以下几个关键参数:</p><ul><li>target: RPC 调用的目标信息,通常是目标队列或服务器名称。(上面已说明)</li><li>version_cap: RPC 接口的版本限制。</li><li>serializer: 用于序列化消息的序列化器。</li><li>transport: 底层的消息通信介质驱动,如 RabbitMQ、Kafka 等。</li></ul><p><em>Transport</em></p><p>Transport 就是 RPC 调用过程中，使用的消息通信介质，如果使用 rabbitmq，那么需要指定 rabbitmq 服务器的连接地址，以及用户名，密码等参数。RPC 调用的 client 和 server 端都需要指定一个 transport 作为消息的 broker. oslo.messaging 中通过 oslo_messaging.get_transport 函数返回一个 transport 对象。</p><p>底层的一些实现原理对分析 RPC 作用不大，暂且不去研读。</p><h2 id="2-cctxt-call-cctxt-cast-oslo-messaging-oslo-messaging-rpc-client-py"><a href="#2-cctxt-call-cctxt-cast-oslo-messaging-oslo-messaging-rpc-client-py" class="headerlink" title="2 - cctxt.call()&#x2F;cctxt.cast() - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;client.py"></a>2 - cctxt.call()&#x2F;cctxt.cast() - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;client.py</h2><p><strong>以 call() 为例</strong></p><details>  <summary><mark><font color=darkred>Function call() Code Detail</font></mark></summary>  <pre><code class="hljs">      def call(self, ctxt, method, **kwargs):        """Invoke a method and wait for a reply. See RPCClient.call()."""        if self.target.fanout:            raise exceptions.InvalidTarget('A call cannot be used with fanout',                                           self.target)<pre><code class="hljs">    msg = self._make_message(ctxt, method, kwargs)    msg_ctxt = self.serializer.serialize_context(ctxt)    timeout = self.timeout    if self.timeout is None:        timeout = self.conf.rpc_response_timeout    cm_timeout = self.call_monitor_timeout    self._check_version_cap(msg.get(&#39;version&#39;))    with metrics.get_collector(self.conf, &quot;rpc_client&quot;,                               target=self.target, method=method,                               call_type=&quot;call&quot;) as metrics_collector:        try:            result = self.transport._send(                self.target, msg_ctxt, msg, wait_for_reply=True,                timeout=timeout, call_monitor_timeout=cm_timeout,                retry=self.retry, transport_options=self.transport_options)        except driver_base.TransportDriverError as ex:            self._metrics_api.rpc_client_exception_total(                self.target, method, &quot;call&quot;, ex.__class__.__name__)            raise ClientSendError(self.target, ex)        except Exception as ex:            if self.conf.oslo_messaging_metrics.metrics_enabled:                metrics_collector.rpc_client_exception_total(                    self.target, method, &quot;call&quot;, ex.__class__.__name__)            raise        return self.serializer.deserialize_entity(ctxt, result)</code></pre><p>  </code></pre></p></details><p><strong>关注 ctxt 参数</strong></p><p>ctxt参数是一个<strong>oslo.context.RequestContext</strong>实例</p><blockquote><ul><li>在RPC调用时,客户端将RequestContext序列化到消息中,服务端从消息中反序列化出该对象。这样,各个分布式节点都可以获取请求上下文信息,保证了认证和策略的一致性。</li><li>RequestContext在OpenStack中用于存储和传递与请求相关的各种核心元数据,是实现认证、授权、审计等功能的基础。</li></ul></blockquote><details>  <summary><mark><font color=darkred>Function RequestContext() Code Detail</font></mark></summary>  <pre><code class="hljs">      class RequestContext(object):<pre><code class="hljs">&quot;&quot;&quot;Helper class to represent useful information about a request context.Stores information about the security context under which the useraccesses the system, as well as additional request information.&quot;&quot;&quot;user_idt_format = &#39;&#123;user&#125; &#123;project_id&#125; &#123;domain&#125; &#123;user_domain&#125; &#123;p_domain&#125;&#39;# Can be overridden in subclasses to specify extra keys that should be# read when constructing a context using from_dict.FROM_DICT_EXTRA_KEYS: ty.List[str] = []@_renamed_kwarg(&#39;user&#39;, &#39;user_id&#39;)@_renamed_kwarg(&#39;domain&#39;, &#39;domain_id&#39;)@_renamed_kwarg(&#39;user_domain&#39;, &#39;user_domain_id&#39;)@_renamed_kwarg(&#39;project_domain&#39;, &#39;project_domain_id&#39;)def __init__(    self,    auth_token: ty.Optional[str] = None,    user_id: ty.Optional[str] = None,    project_id: ty.Optional[str] = None,    domain_id: ty.Optional[str] = None,    user_domain_id: ty.Optional[str] = None,    project_domain_id: ty.Optional[str] = None,    is_admin: bool = False,    read_only: bool = False,    show_deleted: bool = False,    request_id: ty.Optional[str] = None,    resource_uuid: ty.Optional[str] = None,    overwrite: bool = True,    roles: ty.Optional[ty.List[str]] = None,    user_name: ty.Optional[str] = None,    project_name: ty.Optional[str] = None,    domain_name: ty.Optional[str] = None,    user_domain_name: ty.Optional[str] = None,    project_domain_name: ty.Optional[str] = None,    is_admin_project: bool = True,    service_token: ty.Optional[str] = None,    service_user_id: ty.Optional[str] = None,    service_user_name: ty.Optional[str] = None,    service_user_domain_id: ty.Optional[str] = None,    service_user_domain_name: ty.Optional[str] = None,    service_project_id: ty.Optional[str] = None,    service_project_name: ty.Optional[str] = None,    service_project_domain_id: ty.Optional[str] = None,    service_project_domain_name: ty.Optional[str] = None,    service_roles: ty.Optional[ty.List[str]] = None,    global_request_id: ty.Optional[str] = None,    system_scope: ty.Optional[str] = None,):    &quot;&quot;&quot;Initialize the RequestContext    :param overwrite: Set to False to ensure that the greenthread local                      copy of the index is not overwritten.    :param is_admin_project: Whether the specified project is specified in                             the token as the admin project. Defaults to                             True for backwards compatibility.    :type is_admin_project: bool    :param system_scope: The system scope of a token. The value ``all``                         represents the entire deployment system. A service                         ID represents a specific service within the                         deployment system.    :type system_scope: string    &quot;&quot;&quot;    # setting to private variables to avoid triggering subclass properties    self._user_id = user_id    self._project_id = project_id    self._domain_id = domain_id    self._user_domain_id = user_domain_id    self._project_domain_id = project_domain_id    self.auth_token = auth_token    self.user_name = user_name    self.project_name = project_name    self.domain_name = domain_name    self.system_scope = system_scope    self.user_domain_name = user_domain_name    self.project_domain_name = project_domain_name    self.is_admin = is_admin    self.is_admin_project = is_admin_project    self.read_only = read_only    self.show_deleted = show_deleted    self.resource_uuid = resource_uuid    self.roles = roles or []    self.service_token = service_token    self.service_user_id = service_user_id    self.service_user_name = service_user_name    self.service_user_domain_id = service_user_domain_id    self.service_user_domain_name = service_user_domain_name    self.service_project_id = service_project_id    self.service_project_name = service_project_name    self.service_project_domain_id = service_project_domain_id    self.service_project_domain_name = service_project_domain_name    self.service_roles = service_roles or []    if not request_id:        request_id = generate_request_id()    self.request_id = request_id    self.global_request_id = global_request_id    if overwrite or not get_current():        self.update_store()# NOTE(jamielennox): To prevent circular lookups on subclasses that might# point user to user_id we make user/user_id  etc point# to the same private variable rather than each other.user = _moved_property(&#39;user_id&#39;, &#39;user&#39;, target=&#39;_user_id&#39;)domain = _moved_property(&#39;domain_id&#39;, &#39;domain&#39;, target=&#39;_domain_id&#39;)user_domain = _moved_property(    &#39;user_domain_id&#39;, &#39;user_domain&#39;, target=&#39;_user_domain_id&#39;)project_domain = _moved_property(    &#39;project_domain_id&#39;, &#39;project_domain&#39;, target=&#39;_project_domain_id&#39;)user_id = _moved_property(&#39;_user_id&#39;)project_id = _moved_property(&#39;_project_id&#39;)domain_id = _moved_property(&#39;_domain_id&#39;)user_domain_id = _moved_property(&#39;_user_domain_id&#39;)project_domain_id = _moved_property(&#39;_project_domain_id&#39;)</code></pre><p>  </code></pre></p></details><h2 id="3-get-rpc-server-oslo-messaging-oslo-messaging-rpc-server-py"><a href="#3-get-rpc-server-oslo-messaging-oslo-messaging-rpc-server-py" class="headerlink" title="3 - get_rpc_server() - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;server.py"></a>3 - get_rpc_server() - oslo.messaging&#x2F;oslo_messaging&#x2F;rpc&#x2F;server.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_rpc_server</span>(<span class="hljs-params">transport, target, endpoints,</span><br><span class="hljs-params">                   executor=<span class="hljs-literal">None</span>, serializer=<span class="hljs-literal">None</span>, access_policy=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                   server_cls=RPCServer</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Construct an RPC server.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    :param transport: the messaging transport</span><br><span class="hljs-string">    :type transport: Transport</span><br><span class="hljs-string">    :param target: the exchange, topic and server to listen on</span><br><span class="hljs-string">    :type target: Target</span><br><span class="hljs-string">    :param endpoints: a list of endpoint objects</span><br><span class="hljs-string">    :type endpoints: list</span><br><span class="hljs-string">    :param executor: name of message executor - available values are</span><br><span class="hljs-string">                     &#x27;eventlet&#x27; and &#x27;threading&#x27;</span><br><span class="hljs-string">    :type executor: str</span><br><span class="hljs-string">    :param serializer: an optional entity serializer</span><br><span class="hljs-string">    :type serializer: Serializer</span><br><span class="hljs-string">    :param access_policy: an optional access policy.</span><br><span class="hljs-string">           Defaults to DefaultRPCAccessPolicy</span><br><span class="hljs-string">    :type access_policy: RPCAccessPolicyBase</span><br><span class="hljs-string">    :param server_cls: The server class to instantiate</span><br><span class="hljs-string">    :type server_cls: class</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    dispatcher = rpc_dispatcher.RPCDispatcher(endpoints, serializer,<br>                                              access_policy)<br>    <span class="hljs-keyword">return</span> server_cls(transport, target, dispatcher, executor)<br></code></pre></td></tr></table></figure><p><strong>Endpoints</strong></p><p>RPC Server 通过 Endpoint，将方法暴露出去，供 Client 端进行调用。一个 RPC Server 可以指定多个 Endpoint 对象。</p><p><strong>dispatcher</strong><br>RPCDispatcher 负责将接收到的 RPC 请求分发到正确的端点 (Endpoint) 上执行</p>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Openstack-RPC</title>
    <link href="/2024/03/04/Openstack-RPC/"/>
    <url>/2024/03/04/Openstack-RPC/</url>
    
    <content type="html"><![CDATA[<h1 id="Nova"><a href="#Nova" class="headerlink" title="Nova"></a>Nova</h1><h2 id="1-nova-compute-nova-计算服务"><a href="#1-nova-compute-nova-计算服务" class="headerlink" title="1 - nova-compute (nova 计算服务)"></a>1 - nova-compute (nova 计算服务)</h2><p>..&#x2F;stack\nova\nova\compute\rpcapi.py:455: rpc.get_client(target, version_cap, serializer)<br>..&#x2F;stack\nova\nova\compute\rpcapi.py:556: return rpc.get_client(target,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">router</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Provides singleton access to nova.rpc.ClientRouter for this API</span><br><span class="hljs-string"></span><br><span class="hljs-string">    The ClientRouter is constructed and accessed as a singleton to avoid</span><br><span class="hljs-string">    querying all cells for a minimum nova-compute service version when</span><br><span class="hljs-string">    [upgrade_levels]/compute=auto and we have access to the API DB.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">global</span> _ROUTER<br>    <span class="hljs-keyword">if</span> _ROUTER <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">with</span> lockutils.lock(<span class="hljs-string">&#x27;compute-rpcapi-router&#x27;</span>):<br>            <span class="hljs-keyword">if</span> _ROUTER <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                target = messaging.Target(topic=RPC_TOPIC, version=<span class="hljs-string">&#x27;6.0&#x27;</span>)<br>                upgrade_level = CONF.upgrade_levels.compute<br>                <span class="hljs-keyword">if</span> upgrade_level == <span class="hljs-string">&#x27;auto&#x27;</span>:<br>                    version_cap = self._determine_version_cap(target)<br>                <span class="hljs-keyword">else</span>:<br>                    version_cap = self.VERSION_ALIASES.get(upgrade_level,<br>                                                           upgrade_level)<br>                serializer = objects_base.NovaObjectSerializer()<br><br>                <span class="hljs-comment"># NOTE(danms): We need to poke this path to register CONF</span><br>                <span class="hljs-comment"># options that we use in self.get_client()</span><br>                rpc.get_client(target, version_cap, serializer)<br><br>                default_client = self.get_client(target, version_cap,<br>                                                 serializer)<br>                _ROUTER = rpc.ClientRouter(default_client)<br>    <span class="hljs-keyword">return</span> _ROUTER<br></code></pre></td></tr></table></figure><h2 id="2-nova-conductor-nova数据库服务，提供数据库访问"><a href="#2-nova-conductor-nova数据库服务，提供数据库访问" class="headerlink" title="2 - nova-conductor (nova数据库服务，提供数据库访问)"></a>2 - nova-conductor (nova数据库服务，提供数据库访问)</h2><p>..&#x2F;stack\nova\nova\conductor\rpcapi.py:221: self.client &#x3D; rpc.get_client(target,<br>..&#x2F;stack\nova\nova\conductor\rpcapi.py:299: self.client &#x3D; rpc.get_client(target, serializer&#x3D;serializer)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">super</span>(ConductorAPI, self).__init__()<br>    target = messaging.Target(topic=RPC_TOPIC, version=<span class="hljs-string">&#x27;3.0&#x27;</span>)<br>    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.conductor,<br>                                           CONF.upgrade_levels.conductor)<br>    serializer = objects_base.NovaObjectSerializer()<br>    self.client = rpc.get_client(target,<br>                                 version_cap=version_cap,<br>                                 serializer=serializer)<br></code></pre></td></tr></table></figure><h2 id="3-nova-scheduler-nova-调度服务"><a href="#3-nova-scheduler-nova-调度服务" class="headerlink" title="3 - nova-scheduler (nova 调度服务)"></a>3 - nova-scheduler (nova 调度服务)</h2><p>..&#x2F;stack\nova\nova\scheduler\rpcapi.py:129: self.client &#x3D; rpc.get_client(target, version_cap&#x3D;version_cap,</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-built_in">super</span>(SchedulerAPI, self).__init__()<br>    target = messaging.Target(topic=RPC_TOPIC, version=<span class="hljs-string">&#x27;4.0&#x27;</span>)<br>    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.scheduler,<br>                                           CONF.upgrade_levels.scheduler)<br>    serializer = objects_base.NovaObjectSerializer()<br>    self.client = rpc.get_client(target, version_cap=version_cap,<br>                                 serializer=serializer)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>OpenStack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Constan Propagation and Worklist Solver</title>
    <link href="/2024/02/28/Constan-Propagation-and-Worklist-Solver/"/>
    <url>/2024/02/28/Constan-Propagation-and-Worklist-Solver/</url>
    
    <content type="html"><![CDATA[<h1 id="作业导览"><a href="#作业导览" class="headerlink" title="作业导览"></a>作业导览</h1><ul><li>为 Java 实现常量传播算法。</li><li>实现一个通用的 worklist 求解器，并用它来解决一些数据流分析问题，例如本次的常量传播。</li></ul><h1 id="实现ConstantPropagation中的API："><a href="#实现ConstantPropagation中的API：" class="headerlink" title="实现ConstantPropagation中的API："></a>实现ConstantPropagation中的API：</h1><ul><li><strong>CPFact newBoundaryFact(CFG)</strong></li><li><strong>CPFact newInitialFact()</strong></li><li><strong>void meetInto(CPFact, CPFact)</strong></li><li>Value meetValue(Value, Value)</li><li><strong>boolean transferNode(Stmt, CPFact, CPFact)</strong></li><li>Value evaluate(Exp, CPFact)</li></ul><blockquote><p>本次作业只关注 int 类型的常量传播。为了实现这一点，框架代码在 ConstantPropagation 类中提供了 <strong>canHoldInt(Var)</strong> 方法来判断一个变量能否储存 int 类型的值。你需要利用这个方法来判断一个变量是否在本次作业的分析范围内，并忽略那些不在范围内的变量（例如 float 类型的变量）。</p></blockquote><h2 id="1-CPFact-newBoundaryFact-CFG"><a href="#1-CPFact-newBoundaryFact-CFG" class="headerlink" title="1 - CPFact newBoundaryFact(CFG)"></a>1 - CPFact newBoundaryFact(CFG)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CPFact <span class="hljs-title function_">newBoundaryFact</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>pascal.taie.analysis.dataflow.analysis.constprop.CPFact<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CPFact</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MapFact</span>&lt;Var, Value&gt; &#123;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个类表示常量传播中的 data facts，即一个从变量（Var）到格上抽象值（Value）的映射。该类提供了各种 map 相关的操作，例如键值对的查询、更新等等。这些操作大多继承自 <strong>pascal.taie.analysis.dataflow.fact.MapFact</strong>。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">update</span><span class="hljs-params">(Var key, Value value)</span> &#123;<br>    <span class="hljs-keyword">if</span> (value.isUndef()) &#123;<br>        <span class="hljs-comment">// if the client code sets variable key to UNDEF,</span><br>        <span class="hljs-comment">// then we remove the variable from the CPFact</span><br>        <span class="hljs-comment">// as we use absence to represent UNDEF.</span><br>        <span class="hljs-keyword">return</span> remove(key) != <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.update(key, value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>这个函数用来更新CPFact，也就是给CPFact赋值。</p></blockquote><ul><li>pascal.taie.ir.*</li></ul><p>pascal.taie.ir.IR</p><blockquote><p>这是 Tai-e 的 IR 的核心数据结构。它的每个实例储存了一个 Java 方法的各种信息，例如变量、参数、语句等等。</p></blockquote><p>pascal.taie.ir.exp.Var</p><blockquote><p>这个类代表 IR 中的变量。</p></blockquote><p>综上可得：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CPFact <span class="hljs-title function_">newBoundaryFact</span><span class="hljs-params">(CFG&lt;Stmt&gt; cfg)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-type">CPFact</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPFact</span>();<br>    <span class="hljs-keyword">for</span> ( Var <span class="hljs-keyword">var</span> : cfg.getIR().getParams() ) &#123;<br>        result.update(<span class="hljs-keyword">var</span>, Value.getNAC());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-CPFact-newInitialFact"><a href="#2-CPFact-newInitialFact" class="headerlink" title="2 - CPFact newInitialFact()"></a>2 - CPFact newInitialFact()</h2><p>这个相对简单，目的是创建一个CPFact，所以之久使用 new CPFact()，即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> CPFact <span class="hljs-title function_">newInitialFact</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CPFact</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-void-meetInto-CPFact-CPFact"><a href="#3-void-meetInto-CPFact-CPFact" class="headerlink" title="3 - void meetInto(CPFact, CPFact)"></a>3 - void meetInto(CPFact, CPFact)</h2><p>Value meetValue(Value, Value)对应着格上的 meet 操作（⊓，应当在 meetInto() 方法中调用它。</p><img src="/images/Constan-Propagation-and-Worklist-Solver/meet.png" width=600><blockquote><p>也就是下面这四种情况：<br>NAC ^ v &#x3D; NAC<br>UNDEF ^ v &#x3D; v<br>c ^ c &#x3D; c<br>c1 ^ c2 &#x3D; NAC</p></blockquote><p>pascal.taie.analysis.dataflow.analysis.constprop.Value</p><blockquote><p>这个类表示了常量分析中格上的抽象值 (见第 6 讲课件的第 238 页)。它的代码和注释解释了它的用法。你应该用下列的静态方法获取格上抽象值（即该类的实例）：</p></blockquote><p>Value getNAC(): 返回 NAC<br>Value getUndef(): 返回 UNDEF<br>Value makeConstant(int): 返回给定整数在格上对应的抽象值</p><p>根据图中的逻辑关系可得：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Value <span class="hljs-title function_">meetValue</span><span class="hljs-params">(Value v1, Value v2)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-keyword">if</span>(v1.isNAC() || v2.isNAC()) &#123;<br>        <span class="hljs-keyword">return</span> Value.getNAC();<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v1.isConstant() &amp;&amp; v2.isConstant())&#123;<br>        <span class="hljs-keyword">if</span>(v1.getConstant() != v2.getConstant()) &#123;<br>            <span class="hljs-keyword">return</span> Value.getNAC();<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Value.makeConstant(v1.getConstant());<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(v1.isConstant())&#123;<br>        <span class="hljs-keyword">return</span> Value.makeConstant(v1.getConstant());<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> Value.makeConstant(v2.getConstant());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>void meetInto(CPFact, CPFact)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">meetInto</span><span class="hljs-params">(CPFact fact, CPFact target)</span> &#123;<br>    <span class="hljs-comment">//TODO - finish me</span><br>    <span class="hljs-comment">//对于fact里面的每一个键值对，通过合并来更新。</span><br>    fact.entries().forEach(entry -&gt; &#123;<br>        <span class="hljs-type">Var</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> entry.getKey();<br>        <span class="hljs-type">Value</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> entry.getValue();<br>        target.update(key, meetValue(target.get(key), v));<br>        <span class="hljs-comment">//使用meetValue函数来实现meet操作，fact是指上一轮的，target是这一轮的</span><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li><em>java 函数式编程</em></li><li><em>java stream</em></li></ul></blockquote><h2 id="4-boolean-transferNode-Stmt-CPFact-CPFact"><a href="#4-boolean-transferNode-Stmt-CPFact-CPFact" class="headerlink" title="4 - boolean transferNode(Stmt, CPFact, CPFact)"></a>4 - boolean transferNode(Stmt, CPFact, CPFact)</h2><h3 id="Value-evaluate-Exp-CPFact"><a href="#Value-evaluate-Exp-CPFact" class="headerlink" title="Value evaluate(Exp,CPFact)"></a>Value evaluate(Exp,CPFact)</h3><blockquote><p>这个方法会计算表达式（Exp）的值（Value）。当然，此处的值是格上的抽象值。你需要参考第 6 讲课件的第 247 页上的内容来实现它的三种情况。对于其它情况，该方法会像我们在第 2.1 节提到的那样返回 NAC。你应该在 transferNode() 方法中调用它来进行表达式的求值。</p></blockquote><p>1 - 先实现一元的情况：</p><img src="/images/Constan-Propagation-and-Worklist-Solver/transfer-function1.png" width=500><ul><li>exp是一个constant，将int值转换为抽象的Value值并返回。</li></ul><p>pascal.taie.ir.exp.IntLiteral</p><blockquote><p>根据 Java 的语言规范，在 Tai-e 中把常量称作字面量（Literals）。每个 IntLiteral 类的实例都表示一个程序中的整数字面量。可以通过调用 getValue() 方法来获取它的值。</p></blockquote><p>Code:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> IntLiteral intLiteral) &#123;<br>    <span class="hljs-keyword">return</span>  Value.makeConstant(intLiteral.getValue());<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>exp是一个变量值，取出变量Val中的Value值并返回。(CPFact实现从变量（Var）到格上抽象值（Value）的映射)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (exp <span class="hljs-keyword">instanceof</span> Var v) &#123;<br>    <span class="hljs-keyword">return</span> in.get(v);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>exp有两个操作数，且两个操作数并不都是constant，根据图片返回NAC。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!(exp <span class="hljs-keyword">instanceof</span> BinaryExp binaryExp)) &#123;<br>    <span class="hljs-keyword">return</span> Value.getNAC();<br>&#125;<br></code></pre></td></tr></table></figure><p>2 - 处理二元的情况</p><ul><li>将两个操作数的表达式分解成为变量valx，valy和操作符op。</li></ul><p>pascal.taie.ir.exp.Exp</p><blockquote><p>下图是一个继承关系的简单示意图（已略去与本次作业无关的类）。</p></blockquote><img src="/images/Constan-Propagation-and-Worklist-Solver/exp.png" width=500><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> ((BinaryExp) exp).getOperator().toString();<br><span class="hljs-type">Value</span> <span class="hljs-variable">valx</span> <span class="hljs-operator">=</span> in.get(((BinaryExp) exp).getOperand1());<br><span class="hljs-type">Value</span> <span class="hljs-variable">valy</span> <span class="hljs-operator">=</span> in.get(((BinaryExp) exp).getOperand2());<br></code></pre></td></tr></table></figure><ul><li>分别讨论三种情况<blockquote><p>对于除以 0 的情况（出现在 &#x2F; 和 % 中），我们规定结果为 UNDEF。例如，对于 x &#x3D; a &#x2F; 0，x 的值将会是 UNDEF。</p></blockquote><img src="/images/Constan-Propagation-and-Worklist-Solver/transfer-function2.png" width=550></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>((op.equals(<span class="hljs-string">&quot;/&quot;</span>) || op.equals(<span class="hljs-string">&quot;%&quot;</span>)) &amp;&amp; (valY.isConstant() &amp;&amp; valY.getConstant() == <span class="hljs-number">0</span>))&#123;<br>    <span class="hljs-keyword">return</span> Value.getUndef();<br>&#125;<br><br><span class="hljs-keyword">if</span>(valX.isNAC() || valY.isNAC()) &#123;<br>    <span class="hljs-keyword">return</span> Value.getNAC();<br>&#125;<br><br><span class="hljs-keyword">if</span>(valX.isUndef() || valY.isUndef()) &#123;<br>    <span class="hljs-keyword">return</span> Value.getUndef();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>处理条件表达式<blockquote><p>条件表达式（如 a &#x3D;&#x3D; b）的值由 0（若为 False）和 1（若为 True）来表示。</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">calc</span><span class="hljs-params">(<span class="hljs-type">boolean</span> res)</span>&#123;<br>    <span class="hljs-keyword">return</span> res ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>根据op计算结果值并返回</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> valX.getConstant(), y = valY.getConstant();<br><span class="hljs-type">int</span> res;<br><br>res = <span class="hljs-keyword">switch</span> (op)&#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span> -&gt; x + y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;*&quot;</span> -&gt; x * y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span> -&gt; x - y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/&quot;</span> -&gt; x / y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;%&quot;</span> -&gt; x % y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;|&quot;</span> -&gt; x | y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&amp;&quot;</span> -&gt; x &amp; y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;^&quot;</span> -&gt; x ^ y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;==&quot;</span> -&gt; calc(x == y);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;!=&quot;</span> -&gt; calc(x != y);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&lt;&quot;</span> -&gt; calc(x &lt; y);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&gt;&quot;</span> -&gt; calc(x &gt; y);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&lt;=&quot;</span> -&gt; calc(x &lt;= y);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&gt;=&quot;</span> -&gt; calc(x &gt;= y);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&lt;&lt;&quot;</span> -&gt; x &lt;&lt; y;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;&gt;&gt;&quot;</span> -&gt; x &gt;&gt; y;<br>    <span class="hljs-keyword">default</span> -&gt;  x &gt;&gt;&gt; y;<br>&#125;;<br><span class="hljs-keyword">return</span> Value.makeConstant(res);<br></code></pre></td></tr></table></figure><h3 id="boolean-transferNode-Stmt-stmt-CPFact-in-CPFact-out"><a href="#boolean-transferNode-Stmt-stmt-CPFact-in-CPFact-out" class="headerlink" title="boolean transferNode(Stmt stmt, CPFact in, CPFact out)"></a>boolean transferNode(Stmt stmt, CPFact in, CPFact out)</h3><ul><li>普通的语句直接赋值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">change</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span>(Var key : in.keySet())&#123;<span class="hljs-comment">//普通的语句就直接赋值</span><br>    change |= out.update(key, in.get(key));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果是DefinitionStmt，就做相应的处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(stmt <span class="hljs-keyword">instanceof</span> DefinitionStmt&lt;?, ?&gt; def)&#123;<br>    <span class="hljs-type">LValue</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> def.getLValue();<br>    <span class="hljs-keyword">if</span>(left <span class="hljs-keyword">instanceof</span> Var x)&#123;<br>        <span class="hljs-keyword">if</span>(canHoldInt(x))&#123;<br>            <span class="hljs-type">Value</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> evaluate(def.getRValue(), in);<br>            change |= out.update(x, res);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> change;<br></code></pre></td></tr></table></figure><h1 id="实现-Worklist-求解器"><a href="#实现-Worklist-求解器" class="headerlink" title="实现 Worklist 求解器"></a>实现 Worklist 求解器</h1><ul><li><strong>Solver.initializeForward(CFG, DataflowResult)</strong></li><li><strong>WorkListSolver.doSolveForward(CFG, DataflowResult)</strong></li></ul><h2 id="1-Solver-initializeForward-CFG-DataflowResult"><a href="#1-Solver-initializeForward-CFG-DataflowResult" class="headerlink" title="1 - Solver.initializeForward(CFG, DataflowResult)"></a>1 - Solver.initializeForward(CFG, DataflowResult)</h2>]]></content>
    
    
    <categories>
      
      <category>Static Analysis Programming Assignments</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tai-e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Flow Analysis( Foundations )</title>
    <link href="/2024/02/27/Data-Flow-Analysis-Foundations/"/>
    <url>/2024/02/27/Data-Flow-Analysis-Foundations/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Iterative-Algorithm-Another-View"><a href="#1-Iterative-Algorithm-Another-View" class="headerlink" title="1 - Iterative Algorithm, Another View"></a>1 - Iterative Algorithm, Another View</h1><ul><li>假设给定的 CFG 有 k 个节点，迭代算法每次迭代更新每个节点的 OUT[n]</li><li>定义 k-tuple (OUT[n1], … , OUT[nk])，则该元组为集合 V^k 的一个元素（V 是数据流分析的值的域）</li><li>那么每次迭代可以视作作用了转移函数和流控制处理的一次映射，即：F: V^k —&gt; V^k</li><li>整个算法就是在不断地输出这样的 k-tuple 直到出现连续两个相同的为止</li></ul><img src="/images/Data-Flow-Analysis-Foundations/Another-View.png"><blockquote><p>迭代算法会在 X &#x3D; F(X) 处停下来，即数学定义上的一个不动点（fixed point）</p></blockquote><p>Think:</p><ul><li>Is the algorithm guaranteed to terminate or reach the fixed point, or does it always have a solution?</li><li>If so, is there only one solution or only one fixed point? If more than one, is our solution the best one (most precise)?</li><li>When will the algorithm reach the fixed point, or when can we get the solution? (时间复杂度)</li></ul><h1 id="2-Partial-Order"><a href="#2-Partial-Order" class="headerlink" title="2- Partial Order"></a>2- Partial Order</h1><ul><li>偏序关系（Partial Order）满足<strong>自反性</strong>、<strong>反对称性</strong>、<strong>传递性</strong>。</li><li>一个偏序集（poset）中的任意两个元素之间不一定满足偏序关系</li></ul><img src="/images/Data-Flow-Analysis-Foundations/Partial-Order.png" width=550><h1 id="3-Upper-and-Lower-Bounds"><a href="#3-Upper-and-Lower-Bounds" class="headerlink" title="3 - Upper and Lower Bounds"></a>3 - Upper and Lower Bounds</h1><p>上界（upper bound）和下界（lower bound）<br><img src="/images/Data-Flow-Analysis-Foundations/ul-bound.png" width=450></p><p>最小上界（least upper bound）和最大下界（greatest lower bound）<br><img src="/images/Data-Flow-Analysis-Foundations/least-ul-bound.png" width=500></p><blockquote><p>不是每个偏序集都有最小上界（最大下界）；若偏序集存在最小上界（最大下界），则是唯一的</p></blockquote><h1 id="4-Lattice-Semilattice-Complete-and-Product-Lattice"><a href="#4-Lattice-Semilattice-Complete-and-Product-Lattice" class="headerlink" title="4 - Lattice, Semilattice, Complete and Product Lattice"></a>4 - Lattice, Semilattice, Complete and Product Lattice</h1><ul><li>格（Lattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/lattice.png" width=500><ul><li>半格（Semilattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/semilattice.png" width=500><ul><li>全格（Complete Lattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/complete-lattice.png" width=500><blockquote><p>Every <strong>finite</strong> lattice (P is finite) is a complete lattice. ( 有穷格一定是全格，全格不一定是有穷格 )</p></blockquote><ul><li>格的积（Product Lattice）</li></ul><img src="/images/Data-Flow-Analysis-Foundations/product-lattice.png" width=500><blockquote><ul><li>A product lattice is a lattice.</li><li>If a product lattice L is a product of complete lattices, then L is also complete.</li></ul></blockquote><h1 id="5-Data-Flow-Analysis-Framework-via-Lattice"><a href="#5-Data-Flow-Analysis-Framework-via-Lattice" class="headerlink" title="5 - Data Flow Analysis Framework via Lattice"></a>5 - Data Flow Analysis Framework via Lattice</h1><p>A data flow analysis framework (D, L, F) consists of:</p><ul><li>D: a direction of data flow: forwards or backwards.</li><li>L: a lattice including domain of the values V and a meet ∩ or join ∪ operator.</li><li>F: a family of transfer functions from V to V.<blockquote><p>Data flow analysis can be seen as iteratively applying transfer functions and meet&#x2F;join operations on the values of a lattice.</p></blockquote></li></ul><h1 id="6-Monotonicity-and-Fixed-Point-Theorem"><a href="#6-Monotonicity-and-Fixed-Point-Theorem" class="headerlink" title="6 - Monotonicity and Fixed Point Theorem"></a>6 - Monotonicity and Fixed Point Theorem</h1><h2 id="Monotonicity-Define："><a href="#Monotonicity-Define：" class="headerlink" title="Monotonicity Define："></a>Monotonicity Define：</h2><p>一个函数f: L → L (L为lattice)是单调的，当且仅当∀x, y ∈ L,x ⊑ y ⟹ f(x) ⊑ f(y)。</p><h2 id="Fixed-Point-Theorem"><a href="#Fixed-Point-Theorem" class="headerlink" title="Fixed Point Theorem"></a>Fixed Point Theorem</h2><img src="/images/Data-Flow-Analysis-Foundations/fixed-point.png" width=500><p>Let’s prove</p><ul><li>Existence of fixed point.</li><li>The fixed point is the least.</li></ul><h1 id="7-Relate-Iteraive-Algorithm-to-Fixed-Point-Theorem"><a href="#7-Relate-Iteraive-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="7 - Relate Iteraive Algorithm to Fixed Point Theorem"></a>7 - Relate Iteraive Algorithm to Fixed Point Theorem</h1><img src="/images/Data-Flow-Analysis-Foundations/relate.png" width=500><h1 id="8-May-Must-Analysis-A-Lattice-View"><a href="#8-May-Must-Analysis-A-Lattice-View" class="headerlink" title="8 - May&#x2F;Must Analysis, A Lattice View"></a><em>8 - May&#x2F;Must Analysis, A Lattice View</em></h1><img src="/images/Data-Flow-Analysis-Foundations/May-Must-Analysis.png" width=550><blockquote><ul><li>may分析的目的可以看作是报错，因此初始化在bottom，此时分析结果为无错误，因此肯定是一个unsafe的结果；而在top处，分析结果是所有点都出错的，这个肯定是safe的，但是就有些是做了无用功了；因此我们的目的是在二者之间找到一个平衡点，假设{a,c}是truth，那么以此为界可以划分为两块(之所以是区域是因为这其实是一个product lattice)，交界点便是truth。</li><li>must的目的可以看作是删除优化，因此初始化在top，此时分析结果为所有语句都可删除，那肯定是unsafe的，其余类比may可得。</li><li>会发现may分析是查错用的，所以必须都是1才安全，而must是优化用的，所以都是0才最安全，无论是MUST还&gt;是MAY，都是从Unsafe往Safe方向走，达到第一个不动点。</li><li>就是用之前 {a, b, c} 的图来理解，现在有一个 {a} 和 一个 {b}，它们固然可以走到 {a, b, c}，但是它们的 join 是 {a, b}</li><li>图中所有不动点都是safe的，其实是看算法设计情况，如果由不动点在unsafe区域，那么这个算法就是不合格的。</li></ul></blockquote><h1 id="9-Distributivity-and-MOP"><a href="#9-Distributivity-and-MOP" class="headerlink" title="9 - Distributivity and MOP"></a>9 - Distributivity and MOP</h1><ul><li>Meet-Over-All-Paths Solution (MOP)</li></ul><blockquote><p>与之前使用的算法不同，我们以前使用的算法是在运行过程中沿着数据流反复迭代的，而MOP是找出从开头到结尾所有路径，分别进行传递函数计算，最后将算完的所有路径进行⊔&#x2F;⊓</p></blockquote><img src="/images/Data-Flow-Analysis-Foundations/MOP.png" width=500><blockquote><p>由于某些路径可能实际无法到达，因此MOP不是特别精确；而在正常的程序中路径过多，几乎无法全部枚举，因此MOP也不太实际。</p></blockquote><ul><li>Iterative Algorithm vs. MOP<blockquote><p>iterative algorithm: F(x ∪ y)<br>MOP: F(X) ∪ F(y)</p></blockquote></li></ul><p>经过证明MOP ⊑ Ours满足偏序关系，根据之前的图，对于may analyses，MOP更加接近truth因此更加精确。<br>同理，对于must analyses，有Ours ⊑ MOP，根据之前的图，MOP接近truth，更加精准。<br>只要满足了转换函数是distributive的条件，我们的方法就和MOP一样精准，上一篇文章中提到的三个算法都是distributive，下面将一个不是distributive的算法。</p><h1 id="10-Constant-Propagation"><a href="#10-Constant-Propagation" class="headerlink" title="10 - Constant Propagation"></a>10 - Constant Propagation</h1><h2 id="Define"><a href="#Define" class="headerlink" title="Define"></a>Define</h2><p>Given a variable x at program point p, determine whether x is guaranteed to hold a constant value at p.</p><blockquote><p>在程序点p处给定一个变量x，判断x在程序点p处是否<strong>一定</strong>指向一个常量。</p></blockquote><ul><li>The OUT of each node in CFG, includes a set of pairs (x, v) where x is a variable and v is the value held by x after that node.<blockquote><p>这是一个类似must分析，因为必须所有到点p的path都是这个常量才行；但有和传统的不大一样。<br>在CFG中每个节点的输出包括一个对(x, v)，其中x是变量而v是在该节点后x指向的具体值。</p></blockquote></li></ul><p>Why constant propagation?</p><blockquote><p>常量传播可以把原本在运行时的计算转移到编译时进行，减小了程序运行时的开销。同时常量传播还有助于实现其它的优化，比如死代码消除。</p></blockquote><h2 id="Constant-Propagation-Lattice"><a href="#Constant-Propagation-Lattice" class="headerlink" title="Constant Propagation - Lattice"></a>Constant Propagation - Lattice</h2><img src="/images/Data-Flow-Analysis-Foundations/CP-lattice.png" width=500><h2 id="Constant-Propagation-Transfer-Function"><a href="#Constant-Propagation-Transfer-Function" class="headerlink" title="Constant Propagation - Transfer Function"></a>Constant Propagation - Transfer Function</h2><img src="/images/Data-Flow-Analysis-Foundations/CP-function.png" width=500><h2 id="Constant-Propagation-Nondistributivity"><a href="#Constant-Propagation-Nondistributivity" class="headerlink" title="Constant Propagation - Nondistributivity"></a>Constant Propagation - Nondistributivity</h2><img src="/images/Data-Flow-Analysis-Foundations/CP-nondistributivity.png" width=500><h1 id="11-Worklist-Algorithm"><a href="#11-Worklist-Algorithm" class="headerlink" title="11 - Worklist Algorithm"></a>11 - Worklist Algorithm</h1><img src="/images/Data-Flow-Analysis-Foundations/Worklist Algorithm.png" width=500><h1 id="The-X-You-Need-To-Understand-in-This-Lecture"><a href="#The-X-You-Need-To-Understand-in-This-Lecture" class="headerlink" title="The X You Need To Understand in This Lecture"></a>The X You Need To Understand in This Lecture</h1><ul><li>Understand the functional view of iterarive algorithm</li><li>The definitions of lattice and complete lattice</li><li>Understand the fixed-point theorem</li><li>How to summarize may and must analyses in lattices</li><li>The relation between MOP and the solution produced by the iterative algorithm </li><li>Constant propagation analysis </li><li>Worklist algorithm</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Database System Chapter 1</title>
    <link href="/2024/02/26/Database-System-Chapter-1/"/>
    <url>/2024/02/26/Database-System-Chapter-1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据库系统概述"><a href="#1-数据库系统概述" class="headerlink" title="1 - 数据库系统概述"></a>1 - 数据库系统概述</h1><h2 id="数据库的4个基本概念"><a href="#数据库的4个基本概念" class="headerlink" title="数据库的4个基本概念"></a>数据库的4个基本概念</h2><ul><li>Data( 数据 )<blockquote><p>*recode( 记录 )*：<strong>数据是有结构的</strong>，记录是计算机存储数据的一种格式或一种方法。 日常生活中人们可以直接用自然语言来描述事物，而在计算机中常常用记录+语义来描述。</p></blockquote></li><li>Database( 数据库 )<blockquote><p>是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p></blockquote></li><li>DataBase Management System( 数据库管理系统 )<blockquote><ul><li>位于用户应用与操作系统之间的一层数据管理软件。</li><li>是基础软件，是一个大型复杂的软件系统。<img src="/images/Database-System-Chapter-1/DBMS.png" width=120></li></ul></blockquote></li><li>DataBase System( 数据库系统 )<blockquote><p>是指在计算机系统中引入数据库后的系统构成(对数据进行存储、管理、处理和维护的系统)</p></blockquote></li></ul><h2 id="DBMS-的功能："><a href="#DBMS-的功能：" class="headerlink" title="DBMS 的功能："></a>DBMS 的功能：</h2><ul><li>数据定义、组织、存储和管理、操纵</li><li>数据库的事务管理和运行管理（安全性、完整性、并发控制、恢复）</li><li>数据库的建立和维护</li></ul><h2 id="数据库系统的特点"><a href="#数据库系统的特点" class="headerlink" title="数据库系统的特点"></a>数据库系统的特点</h2><ul><li>数据结构化<blockquote><p>数据的<strong>整体</strong>结构化是数据库的主要特征之一</p></blockquote></li><li>数据的共享性高，冗余度低且易扩充<blockquote><p>数据面向整个系统，可以被多个用户、多个应用共享使用。<br><img src="/images/Database-System-Chapter-1/share.png" width=400></p></blockquote></li><li>数据独立性强<blockquote><p>数据独立性由数据库管理系统的二级映像功能来保证</p></blockquote></li><li>数据由数据库管理系统统一管理和控制<blockquote><ul><li>数据的安全性（Security）保护</li><li>数据的完整性（Integrity）检查</li><li>并发控制（Concurrency Control）</li><li>数据库恢复（Recovery）</li></ul></blockquote></li></ul><h1 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2 - 数据模型"></a>2 - 数据模型</h1><p>数据模型是对现实世界数据特征的抽象</p><p><strong>数据模型的组成要素</strong>：</p><ul><li><p>数据结构–描述系统的静态特性</p></li><li><p>数据操作–描述系统的动态特性</p></li><li><p>完整性约束–给定的数据模型中数据及其联系所具有的制约和<br>依存规则。</p></li><li><p>概念模型：<br>实体-联系方法（Entity-Relationship Approach）（E-R模型）：</p></li></ul><img src="/images/Database-System-Chapter-1/E-R.png" width=500><ul><li><p><strong>逻辑模型</strong>：</p><blockquote><p>层次结构-层次模型、网状结构–网状模型、关系结构—关系模型</p></blockquote></li><li><p>物理模型</p></li></ul><h1 id="3-数据库系统的结构"><a href="#3-数据库系统的结构" class="headerlink" title="3 - 数据库系统的结构"></a>3 - 数据库系统的结构</h1><ul><li>模式（Schema）<blockquote><p>是对数据库逻辑结构和特征的描述<br>是型的描述，不涉及具体值<br>模式是相对稳定的</p></blockquote></li><li>实例（Instance）<blockquote><p>数据库某一时刻的状态——模式的一个具体值<br>同一个模式可以有很多实例<br>n实例随数据库中的数据的更新而变动</p></blockquote></li></ul><p>数据库系统的三级模式结构:</p><img src="/images/Database-System-Chapter-1/三级模式.png" width=600><blockquote><ul><li>外模式（也称子模式或用户模式）</li><li>模式（逻辑模式）</li><li>内模式（也称存储模式）（一个数据库只有一个内模式）</li></ul></blockquote><p>数据库的二级映像功能</p><ul><li>外模式／模式映像</li><li>模式／内模式映像<blockquote><p>数据独立性（物理独立性、逻辑独立性）由数据库管理系统的二级映像功能来保证。</p><ul><li>物理独立性是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。</li><li>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</li></ul></blockquote></li></ul><h1 id="4-数据库系统的组成（略）"><a href="#4-数据库系统的组成（略）" class="headerlink" title="4 - 数据库系统的组成（略）"></a>4 - 数据库系统的组成（略）</h1>]]></content>
    
    
    <categories>
      
      <category>Database System</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJUPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Live Variable Analysis and Iterative Solver</title>
    <link href="/2024/02/23/Live-Variable-Analysis-and-Iterative-Solver/"/>
    <url>/2024/02/23/Live-Variable-Analysis-and-Iterative-Solver/</url>
    
    <content type="html"><![CDATA[<h1 id="作业导览"><a href="#作业导览" class="headerlink" title="作业导览"></a>作业导览</h1><ul><li>为 Java 实现一个活跃变量分析（Live Variable Analysis）。</li><li>实现一个通用的迭代求解器（Iterative Solver），用于求解数据流分析问题，也就是本次作业中的活跃变量分析。</li></ul><h1 id="实现LiveVariableAnalysis中的API"><a href="#实现LiveVariableAnalysis中的API" class="headerlink" title="实现LiveVariableAnalysis中的API"></a>实现LiveVariableAnalysis中的API</h1><ul><li><strong>SetFact newBoundaryFact(CFG)</strong></li><li><strong>SetFact newInitialFact()</strong></li><li><strong>void meetInto(SetFact,SetFact)</strong></li><li><strong>boolean transferNode(Stmt,SetFact,SetFact)</strong></li></ul><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/LiveVariableAnalysis.png" width=400><h2 id="1-newBoundaryFact-newInitialFact-CFG"><a href="#1-newBoundaryFact-newInitialFact-CFG" class="headerlink" title="1 - newBoundaryFact() &amp; newInitialFact(CFG)"></a>1 - newBoundaryFact() &amp; newInitialFact(CFG)</h2><p>由于是may分析，采用的是并运算符，且是正向传递的，所以每个BB的In都因该初始化为空。</p><p>pascal.taie.analysis.dataflow.fact.SetFact<Var></p><blockquote><p>这个泛型类用于把 data fact 组织成一个集合。它提供了各种集合操作，如添加、删除元素，取交集、并集等。你同样需要阅读源码和注释来理解如何使用这个类表示活跃变量分析中的各种 data fact。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.add(e);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.remove(e);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">union</span><span class="hljs-params">(SetFact&lt;E&gt; other)</span> &#123;<br>    <span class="hljs-keyword">return</span> set.addAll(other.set);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>Set中add方法可以向集合中添加单个元素。</li><li>union使用数组工具类 Set 将参数 other 对象中的集合中的所有元素添加到当前对象的集合中，并返回添加操作是否成功的布尔值。</li></ul></blockquote></blockquote><h2 id="2-meetInto-SetFact-SetFact"><a href="#2-meetInto-SetFact-SetFact" class="headerlink" title="2 - meetInto(SetFact,SetFact)"></a>2 - meetInto(SetFact,SetFact)</h2><ul><li>该函数的功能就是将两个集合合并，所以直接采用union方法进行合并即可。</li><li>每个SetFact<Var>包括了一个Var集合的类成员和若干操作集合的方法，每个 node ( 程序点 )的 IN&#x2F;OUT 都拥有一个 SetFact<Var>. 初始化时因为 LiveVariableAnalysis 都要初始化为空集，返回 new 的值即可。</li></ul><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/meetInto.png" width=550><h2 id="3-transferNode-Stmt-SetFact-SetFact"><a href="#3-transferNode-Stmt-SetFact-SetFact" class="headerlink" title="3 - transferNode(Stmt,SetFact,SetFact)"></a>3 - transferNode(Stmt,SetFact,SetFact)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// out -&gt; newInfact</span><br>SetFact&lt;Var&gt; newInFact = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SetFact</span>&lt;&gt;();<br>newInFact.union(out);   <br><br><span class="hljs-comment">// outFact - def</span><br><span class="hljs-keyword">if</span> (stmt.getDef().isPresent()) &#123; <br>    <span class="hljs-type">LValue</span> <span class="hljs-variable">def</span> <span class="hljs-operator">=</span> stmt.getDef().get();<br>    <span class="hljs-keyword">if</span> (def <span class="hljs-keyword">instanceof</span> Var) &#123;<br>        newInFact.remove((Var) def);<br>    &#125;<br>&#125;<span class="hljs-comment">// 因为表达式左边也就是def，是一个Var，所以直接用Optional来表示。</span><br><br><span class="hljs-comment">// (outFact - def ) + use</span><br><span class="hljs-keyword">for</span> (RValue use : stmt.getUses()) &#123;<br>    <span class="hljs-keyword">if</span> (use <span class="hljs-keyword">instanceof</span>  Var) &#123;<br>        newInFact.add((Var) use);<br>    &#125;<br>&#125;<span class="hljs-comment">// 因为表达式右也就是use，是可能存在多个值的，所以直接用List来表示。</span><br></code></pre></td></tr></table></figure><p>Java 8 Optional</p><ul><li>Optional 类是一个可以为null的容器对象。<strong>如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。</strong></li><li>Optional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。</li><li>Optional 类的引入很好的解决空指针异常。</li></ul><p>Java instanceof</p><ul><li>instanceof是Java中的二元运算符，<strong>左边是对象</strong>，<strong>右边是类</strong>；当对象是右边类或子类所创建对象时，返回true；否则，返回false。</li></ul><p><em><strong>LValue &amp; RValue</strong></em><br>pascal.taie.ir.exp.Exp：是IR 中的一个关键接口，用于表示程序中的所有表达式。</p><ul><li>LValue:赋值语句左侧的表达式，如变量（x &#x3D; … ）、字段访问（x.f &#x3D; …）或数组访问（x[i] &#x3D; …）<blockquote><p>从outFact中remove掉def，需要用到LValue，因为定义是在表达式的左边，而def只有一个，故用Optional表示。</p></blockquote></li><li>RValue:赋值语句右侧的表达式，如数值字面量（… &#x3D; 1;）或二元表达式（… &#x3D; a + b;）<blockquote><p>从outFact中remove掉use，需要用到RValue，因为引用变量( use 变量 )是在表达式的右边，而use可能不止一个，故用List来表示。</p></blockquote></li></ul><p>getDef() &amp; getUses()</p><p>最后由于这个函数在伪代码中是需要判断前后值是否改变，且函数返回值的类型是boolean，所以需要添加判断语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!newInFact.equals(in)) &#123;<br>    in.set(newInFact);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><h1 id="实现迭代求解器"><a href="#实现迭代求解器" class="headerlink" title="实现迭代求解器"></a>实现迭代求解器</h1><ul><li>Solver.initializeBackward(CFG,DataflowResult)</li><li>IterativeSolver.doSolveBackward(CFG,DataflowResult)</li></ul><p>相关提示：</p><blockquote><p>每个 Solver 对象都在字段 analysis 中保存了相应的数据流分析对象，在本次作业中就是一个 LiveVariableAnalysis 对象。你需要用它提供的相关接口来实现分析求解器。</p></blockquote><h2 id="1-Solver-initializeBackward-CFG-DataflowResult"><a href="#1-Solver-initializeBackward-CFG-DataflowResult" class="headerlink" title="1 - Solver.initializeBackward(CFG,DataflowResult)"></a>1 - Solver.initializeBackward(CFG,DataflowResult)</h2><p>实现伪代码：</p><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/initializeBackward.png" width=300><p>DataflowResult:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Fact <span class="hljs-title function_">getInFact</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">return</span> inFacts.get(node);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setInFact</span><span class="hljs-params">(Node node, Fact fact)</span> &#123;<br>    inFacts.put(node, fact);<br>&#125;   <br></code></pre></td></tr></table></figure><blockquote><p>该类对象用于维护数据流分析的 CFG 中的 fact。可以通过它的 API 获取( get )、设置( set ) CFG 节点( node )的 IN facts 和 OUT facts。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializeBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    analysis.newBoundaryFact(cfg);<br>    <span class="hljs-keyword">for</span> (Node node : cfg.getNodes())&#123;<br>        <span class="hljs-keyword">if</span> ( cfg.isExit(node) )&#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        result.setInFact(node, analysis.newInitialFact());<br>        result.setOutFact(node, analysis.newInitialFact());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>需要判断node是否到达exit( 末尾 )。</li></ul></blockquote><h2 id="2-IterativeSolver-doSolveBackward-CFG-DataflowResult"><a href="#2-IterativeSolver-doSolveBackward-CFG-DataflowResult" class="headerlink" title="2 - IterativeSolver.doSolveBackward(CFG,DataflowResult)"></a>2 - IterativeSolver.doSolveBackward(CFG,DataflowResult)</h2><p>实现伪代码：</p><img src="/images/Live-Variable-Analysis-and-Iterative-Solver/doSolveBackward.png" width=300><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSolveBackward</span><span class="hljs-params">(CFG&lt;Node&gt; cfg, DataflowResult&lt;Node, Fact&gt; result)</span> &#123;<br>    <span class="hljs-comment">// TODO - finish me</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">changed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span> (changed) &#123;<br>        changed = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (Node node : cfg.getNodes()) &#123;<br>            <span class="hljs-keyword">if</span> (cfg.isExit(node)) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (Node succNode : cfg.getSuccsOf(node)) &#123;<br>                analysis.meetInto(result.getInFact(succNode), result.getOutFact(node));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (analysis.transferNode(node, result.getInFact(node), result.getOutFact(node))) &#123;<br>                changed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>pascal.taie.analysis.graph.cfg.CFG</p><ul><li><p>通过一个 for 循环遍历其中的所有节点:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CFG&lt;Node&gt; cfg = ...;<br>    <span class="hljs-keyword">for</span> (Node node : cfg) &#123;<br>        ...<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>通过 CFG.getPredsOf(Node) 和 CFG.getSuccsOf(Node) 这两个方法遍历 CFG 中节点的所有前驱和后继:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Node succ : cfg.getSuccsOf(node)) &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis Programming Assignments</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tai-e</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Data Flow Analysis( Application )</title>
    <link href="/2024/02/20/Data-Flow-Analysis-I/"/>
    <url>/2024/02/20/Data-Flow-Analysis-I/</url>
    
    <content type="html"><![CDATA[<h1 id="Overview-of-Data-Flow-Analysis"><a href="#Overview-of-Data-Flow-Analysis" class="headerlink" title="Overview of Data Flow Analysis"></a>Overview of Data Flow Analysis</h1><h2 id="1-Data-Flow-Analysis"><a href="#1-Data-Flow-Analysis" class="headerlink" title="1 - Data Flow Analysis"></a>1 - Data Flow Analysis</h2><p>Data Flow Analysis -&gt; How Data Flows on CFG<br>How <em>application-specific</em> Data( Abstraction ) <em>Flows</em>( Over-approximation ) through the <strong>Nodes</strong>( BB ) and <strong>Edges</strong>( control flows ) of CFG?</p><h1 id="Preliminaries-of-Data-Flow-Analysis"><a href="#Preliminaries-of-Data-Flow-Analysis" class="headerlink" title="Preliminaries of Data Flow Analysis"></a>Preliminaries of Data Flow Analysis</h1><h2 id="1-Input-and-Output-States"><a href="#1-Input-and-Output-States" class="headerlink" title="1 - Input and Output States"></a>1 - Input and Output States</h2><ul><li>Each execution of an IR statement transforms an input state to a new output state.</li><li>The input( output ) state is associated with the program point before( after ) the statement.</li></ul><img src="/images/Data-Flow-Analysis-I/Input-Output.png" width=650><ul><li><p>In each data-flow analysis application, we associate with every program point a <strong>data-flow value</strong> that represents and <em>abstraction</em> of the set of all possible <strong>program states</strong> that can be abserved foe that point.</p><blockquote><p>在数据流分析应用中，将每一个 program point 与一个 表示该点所有观测到的 program states 的集合的抽象的数据流值（data-flow value） 联系起来。</p></blockquote></li><li><p>Data-flow analysis is to <strong>find a solution</strong> to a set of <em><strong>safe-approximation-directed constraints</strong></em> on the IN[s]’s and OUT[s]’s, for <em>all statements s.</em></p><ul><li>constraints based on semantics of statements( transfer functions ).</li><li>constraints baesd on the flows of control.<blockquote><p>数据流分析是对所有的语句，通过解析 safe-approximation 的约束规则，得到一个 solution（给每个 program point 一个 data-flow value）。</p></blockquote></li></ul></li></ul><h2 id="2-Notations-for-Transfer-Function’s-Constraints"><a href="#2-Notations-for-Transfer-Function’s-Constraints" class="headerlink" title="2 - Notations for Transfer Function’s Constraints"></a>2 - Notations for Transfer Function’s Constraints</h2><p>Forward &amp; Backward</p><img src="/images/Data-Flow-Analysis-I/Notations-Function.png" width=480><h2 id="3-Notations-for-Control-Flow’s-Constraints"><a href="#3-Notations-for-Control-Flow’s-Constraints" class="headerlink" title="3 - Notations for Control Flow’s Constraints"></a>3 - Notations for Control Flow’s Constraints</h2><p>Control flow within a BB &amp; Control flow among BBs</p><img src="/images/Data-Flow-Analysis-I/Notations-ControlFlow.png" width=550><h1 id="Reaching-Definitions-Analysis-定义可达性分析"><a href="#Reaching-Definitions-Analysis-定义可达性分析" class="headerlink" title="Reaching Definitions Analysis( 定义可达性分析 )"></a><em>Reaching Definitions Analysis( 定义可达性分析 )</em></h1><h2 id="1-Reaching-Definitions"><a href="#1-Reaching-Definitions" class="headerlink" title="1 - Reaching Definitions"></a>1 - Reaching Definitions</h2><p>A definition d at program point p reaches a point q if there is a path from p to q such that d is not “killed” along that path.</p><img src="/images/Data-Flow-Analysis-I/Reaching-Definitions.png" width=350><blockquote><ul><li>A definition of a variable v is a statement that assigns a value to v.</li><li>Translated as: definition of variable v at program point p reaches point q if there is a path from p to q such that <em><strong>no new definition of v</strong></em> appears on that path.</li></ul></blockquote><h2 id="2-Understanding-Reaching-Definitions"><a href="#2-Understanding-Reaching-Definitions" class="headerlink" title="2 - Understanding Reaching Definitions"></a>2 - Understanding Reaching Definitions</h2><p>定义可达性可以用于侦测可能的未定义的变量。</p><p>理解定义可达性分析：</p><ul><li><p>用一个比特表示某个变量在某一点的定义可达性。</p></li><li><p>用一个 n 维比特向量表示 n 个变量在某一点的定义可达性。</p></li><li><p>Data Flow Values&#x2F;Facts</p><blockquote><p>Represented by bit vectors  </p><img src="/images/Data-Flow-Analysis-I/bit-vectors.png" width=350>  </blockquote></li><li><p>Transfer Function</p><blockquote><img src="/images/Data-Flow-Analysis-I/TF.png" width=350>  <blockquote><p>genB就是B里面的definition,killB就是其他BB里面被覆盖掉的<br>definition。</p></blockquote></blockquote></li><li><p>Control Flow</p><blockquote><img src="/images/Data-Flow-Analysis-I/CF.png" width=350></blockquote></li></ul><h2 id="3-Algorithm-of-Reaching-Definitions-Analysis"><a href="#3-Algorithm-of-Reaching-Definitions-Analysis" class="headerlink" title="3 - Algorithm of Reaching Definitions Analysis"></a>3 - Algorithm of Reaching Definitions Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithm.png" width=500><blockquote><p>在算法模板中边界条件（OUT[entry]）单独初始化。<br>对于 OUT[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top。</p></blockquote><h2 id="4-Why-this-iterative-algorithm-can-finally-stop"><a href="#4-Why-this-iterative-algorithm-can-finally-stop" class="headerlink" title="4 - Why this iterative algorithm can finally stop?"></a>4 - Why this iterative algorithm can finally stop?</h2><p>对于 Transfer Function，OUT[S] 只受 IN[S] 的影响，当个更多的 facts 流入 IN[S] 时，要么被 kill 要么存活下来并永远被保留，故 OUT[S] <strong>永远不会缩减（e.g. 0 &#x3D;&gt; 1 或 1 &#x3D;&gt; 1）</strong>，又因为定义的变量数量是有限的，故该迭代一定会停下来（实际上到达了一个不动点）</p><blockquote><p>Reach a fixed point also related with monotonicity( 单调性 )</p></blockquote><h1 id="Live-Variables-Analysis-活跃变量分析"><a href="#Live-Variables-Analysis-活跃变量分析" class="headerlink" title="Live Variables Analysis( 活跃变量分析 )"></a><em>Live Variables Analysis( 活跃变量分析 )</em></h1><h2 id="1-Live-Variables-Define"><a href="#1-Live-Variables-Define" class="headerlink" title="1 - Live Variables Define"></a>1 - Live Variables Define</h2><p>Live variables analysis tells whether the value of variable v at program point p could be used along some path in CFG starting at P. If so, v is live at p; otherwise, v is dead at p.</p><img src="/images/Data-Flow-Analysis-I/Live-Variables.png" width=500><blockquote><p>活跃变量信息可用于寄存器分配（倾向于使用存有 dead value 的寄存器来存新数据）</p></blockquote><h2 id="2-Understanding-Live-Variables-Analysis"><a href="#2-Understanding-Live-Variables-Analysis" class="headerlink" title="2 - Understanding Live Variables Analysis"></a>2 - Understanding Live Variables Analysis</h2><p>理解活跃变量分析：</p><ul><li>用一个比特表示某个变量在某一点是否活跃</li><li>用一个 n 维比特向量表示 n 个变量在某一点是否活跃</li></ul><img src="/images/Data-Flow-Analysis-I/Unerstanding-Live-Variables.png" width=650><blockquote><p>注意use的定义为：在重定义之前被使用。</p></blockquote><h2 id="3-Alogrithm-of-Live-Variables-Analysis"><a href="#3-Alogrithm-of-Live-Variables-Analysis" class="headerlink" title="3 - Alogrithm of Live Variables Analysis"></a>3 - Alogrithm of Live Variables Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithm-LV.png" width=650><blockquote><p>在算法模板中边界条件（IN[entry]）单独初始化<br>对于 IN[B]，may analysis 一般初始化为空；must analysis 一般初始化为 top</p></blockquote><h1 id="Available-Expressions-Analysis-可用表达式分析"><a href="#Available-Expressions-Analysis-可用表达式分析" class="headerlink" title="Available Expressions Analysis( 可用表达式分析 )"></a><em>Available Expressions Analysis( 可用表达式分析 )</em></h1><h2 id="1-Available-Expressions-Define"><a href="#1-Available-Expressions-Define" class="headerlink" title="1 - Available Expressions Define"></a>1 - Available Expressions Define</h2><p>An expression <strong>x op y</strong> is available at program point p if (1) all paths from th entry to p must pass through the evaluation of x op y, and (2) after the last evaluation of x op y, there is no redefinition of x or y.</p><blockquote><p>一个表达式，形如 x op y，在某个 program point p 是可用的，需要满足：</p><ul><li>从 ENTRY 到 p 的所有路径都必须计算过 x op y 的值</li><li>在这些路径各自最后一次计算该表达式的值之后没有修改过 x 或 y 的值</li></ul></blockquote><h2 id="2-Understanding-Available-Expressions-Analysis"><a href="#2-Understanding-Available-Expressions-Analysis" class="headerlink" title="2 - Understanding Available Expressions Analysis"></a>2 - Understanding Available Expressions Analysis</h2><p>理解可用表达式分析：</p><ul><li>用一个比特表示某个表达式在某点是否可用</li><li>用一个 n 维比特向量表示 n 个表达式在某点是否可用</li><li>注意这是一个 must analysis</li></ul><img src="/images/Data-Flow-Analysis-I/Understanding-AE.png" width=650><blockquote><ul><li>传递函数和控制流函数如果所示，经过一个BB块的运算，将kill掉包含被重定义过变量的表达式，并加入新的表达式。</li><li>由于是must分析，所以控制流使用meet交集。</li><li>（may分析是只要有某条路径可以就行，must分析是所有路径都要满足才行。may一般用于检测是否使用并删除未使用，must用于替换）</li><li>must分析是一种safe并且under的approximation，即允许漏报的分析。看右下角例子，按照算法其实这个错了，第二个块由于x被重定义导致OUT应该变为空集的。如果由一种特殊情况，x被重定义为和原本一样的数值，那么这个表达式仍然是可以替换的，但是为了safe，算法还是把他排除了，这就是一种漏报，成为under-approximation。</li></ul></blockquote><h2 id="3-Algorithm-of-Available-Expressions-Analysis"><a href="#3-Algorithm-of-Available-Expressions-Analysis" class="headerlink" title="3 - Algorithm of Available Expressions Analysis"></a>3 - Algorithm of Available Expressions Analysis</h2><img src="/images/Data-Flow-Analysis-I/Algorithmi-AE.png" width=650><h1 id="Analysis-Comparison"><a href="#Analysis-Comparison" class="headerlink" title="Analysis Comparison"></a>Analysis Comparison</h1><img src="/images/Data-Flow-Analysis-I/Analysis-Comparison.png" width=650><h1 id="The-X-You-Need-To-Understand-in-This-Lecture"><a href="#The-X-You-Need-To-Understand-in-This-Lecture" class="headerlink" title="The X You Need To Understand in This Lecture"></a>The X You Need To Understand in This Lecture</h1><ul><li>Understand the three data flow analyses:<blockquote><p>-reaching definitions<br>-live variables<br>-available expressions</p></blockquote></li><li>Can tell the differences and similarities of the three data flow analyses</li><li>Understand the iterative algorithm and cna tell why it is able to terminate</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intermediate Representation</title>
    <link href="/2024/02/19/Intermediate-Representation/"/>
    <url>/2024/02/19/Intermediate-Representation/</url>
    
    <content type="html"><![CDATA[<h1 id="Compilers-and-Static-Analyzers"><a href="#Compilers-and-Static-Analyzers" class="headerlink" title="Compilers and Static Analyzers"></a>Compilers and Static Analyzers</h1><h2 id="1-Compiler"><a href="#1-Compiler" class="headerlink" title="1 - Compiler"></a>1 - Compiler</h2><p>Source Code -&gt; Scanner( 词法分析 ) -&gt; <em>Tokens</em> -&gt; Parser( 语法分析 ) -&gt; <em>AST</em> -&gt; Type Checker( 类型检查 ) -&gt; <em>Decorated AST</em> -&gt; Translatror -&gt; <em>IR</em> -&gt; Code Generator -&gt; Machine Code.</p><p>静态分析需要在编译器前端生成的 IR 的基础上进行代码优化。</p><h1 id="AST-vs-IR"><a href="#AST-vs-IR" class="headerlink" title="AST vs. IR"></a>AST vs. IR</h1><img src="/images/Intermediate-Representation/AST-IR.png" alt="AST vs. IR" width=550><h2 id="1-AST"><a href="#1-AST" class="headerlink" title="1 - AST"></a>1 - AST</h2><ul><li>high-level and closed to grammar structure.</li><li>usually language dependent.</li><li>suitable for fast type checking.</li><li>suitable for fast type checking.</li><li>lack of control flow information.</li></ul><h1 id="IR-Three-Address-Code-3AC"><a href="#IR-Three-Address-Code-3AC" class="headerlink" title="IR:Three-Address Code( 3AC )"></a>IR:Three-Address Code( 3AC )</h1><h2 id="1-Intermediate-Representation-IR-“3-address”-form"><a href="#1-Intermediate-Representation-IR-“3-address”-form" class="headerlink" title="1 - Intermediate Representation( IR “3-address” form )"></a>1 - Intermediate Representation( IR “3-address” form )</h2><ul><li>low-level and closed to machine code.</li><li>usually language independent.</li><li>compact and uniform.</li><li>contains control flow information.</li><li><strong>usually considered as the basis for static analysis</strong></li></ul><h2 id="2-Some-Common-3AC-Forms"><a href="#2-Some-Common-3AC-Forms" class="headerlink" title="2 - Some Common 3AC Forms"></a>2 - Some Common 3AC Forms</h2><ul><li>x &#x3D; y <em>bop</em> z</li><li>x &#x3D; <em>uop</em> y</li><li>x &#x3D; y</li><li>goto L</li><li>if x goto L</li><li>if x rop y goto L</li></ul><h1 id="3AC-in-Real-Static-Analyzer-Soot"><a href="#3AC-in-Real-Static-Analyzer-Soot" class="headerlink" title="3AC in Real Static Analyzer: Soot"></a>3AC in Real Static Analyzer: Soot</h1><h2 id="1-Some-real-world-complicated-forms"><a href="#1-Some-real-world-complicated-forms" class="headerlink" title="1 - Some real-world complicated forms"></a>1 - Some real-world complicated forms</h2><p>Java Src</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> nju.sa.examples;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Class3AC</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3AC(jimple)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">nju</span>.sa.examples.Class3AC <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Object<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> pi;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> &lt;init&gt;()<br>    &#123;<br>        nju.sa.examples.Class3AC r0;<br>        r0 := <span class="hljs-meta">@this</span>: nju.sa.examples.Class3AC;<br>        specialinvoke r0.&lt;java,lang.Object: <span class="hljs-keyword">void</span> &lt;init&gt;()&gt;();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(java.lang.String[])</span><br>    &#123;<br>        java.lang.String[] r0;<br>        r0 := <span class="hljs-meta">@parameter0</span>: java.lang.string[];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> &lt;clinit&gt;()<br>    &#123;<br>        &lt;nju.sa.examples.Class3AC: <span class="hljs-type">double</span> pi&gt; = <span class="hljs-number">3.14</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Static-Single-Assignment-SSA-–-Optional-material"><a href="#Static-Single-Assignment-SSA-–-Optional-material" class="headerlink" title="Static Single Assignment ( SSA ) – Optional material"></a>Static Single Assignment ( SSA ) – <em>Optional material</em></h1><p>All assignments in SSA are to variables with distinct names.</p><img src="/images/Intermediate-Representation/SSA.png" alt="SSA" width=400><p>Why not SSA?</p><ul><li>SSA may introduce too many variables and phi-functions.</li><li>May introduce inefficiency problem when translating to machine code (due to copy operations).</li></ul><h1 id="Basic-Blocks-BB"><a href="#Basic-Blocks-BB" class="headerlink" title="Basic Blocks( BB )"></a>Basic Blocks( BB )</h1><p>Define: Basic blocks( BB ) are maximal sequences of consecutive three-address instructions with the properties that</p><ul><li>It can be entered only at the beginning, i.e., the first instruction in the block.</li><li>It can be exited only at the end, i.e., the last instruction in the block.</li></ul><p><strong>How to build Basic Blocks?</strong></p><ul><li>Determine the leaders in P <blockquote><ul><li>The first instruciont in P is a leader.</li><li>Any target instruction of a conditional or unconditional jump is a leader.</li><li>Any instruction that immediately follows a conditional or unconditional jump is a leader.</li></ul></blockquote></li><li>Build BBs for P</li></ul><h1 id="Control-Flow-Graphs-CFG"><a href="#Control-Flow-Graphs-CFG" class="headerlink" title="Control Flow Graphs ( CFG )"></a>Control Flow Graphs ( CFG )</h1><p>How to build Control Flow Graph( CFG )</p><ul><li>The nodes of CFG are basic blocks.</li><li>There is an edge from block A to block B if and only if<blockquote><ul><li>There is a conditional or unconditional jump from the end of A to the beginning of B.</li><li>B immediately follows A in the original order of instructions <em>and A does not end in an unconditional jump</em>.</li></ul></blockquote></li><li>It is normal to replace the jumps to instruction labels by jumps to basic blocks.</li></ul><img src="/images/Intermediate-Representation/CFG.png" alt="Control Flow Graphs( CFG )" width=650><h1 id="The-X-You-Need-To-Understan-in-This-Lecture"><a href="#The-X-You-Need-To-Understan-in-This-Lecture" class="headerlink" title="The X You Need To Understan in This Lecture"></a>The X You Need To Understan in This Lecture</h1><ul><li>The relation between compilers and static analyhzers.</li><li>Understan 3AC and its common forms( in IR jimple ).</li><li>How to build basic blocks on top of IR.</li><li>How to construct control flow graphs on top of BBs?</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction</title>
    <link href="/2024/02/19/Introduction/"/>
    <url>/2024/02/19/Introduction/</url>
    
    <content type="html"><![CDATA[<h1 id="Static-Analysis"><a href="#Static-Analysis" class="headerlink" title="Static Analysis"></a>Static Analysis</h1><h2 id="1-Define"><a href="#1-Define" class="headerlink" title="1 - Define"></a>1 - Define</h2><p>静态分析通过分析程序 P 来推理其行为，并在运行 P 之前确定其是否满足某些属性。</p><blockquote><p>Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P.</p></blockquote><ul><li>Does P contain any private information leaks?</li><li>Does P dereference any null pointers?</li><li>Are all the cast operations in P safe?<br><em>- 是否存在强制类型转换异常？</em></li><li>Can v1 and v2 in P point to the same memory location?</li><li>Will certain assert staements in P fail?<br><em>- 是否存在 fail 的 assert 语句？</em></li><li>Is this piece of code in P dead(so that it could be eliminated?)<br><em>- 是否存在可以删除的死代码？</em></li></ul><h2 id="2-Rice’s-Theorem-莱斯定理"><a href="#2-Rice’s-Theorem-莱斯定理" class="headerlink" title="2 - Rice’s Theorem(莱斯定理)"></a>2 - Rice’s Theorem(莱斯定理)</h2><p>通俗的讲：不存在完美的静态分析方法(Perfect static analysis)。</p><blockquote><p>Perfect static &#x3D; Sound &amp; Complete</p></blockquote><img src="/images/Introduction/Sound-Complete.png" width=500 /><p>真正的有用的静态分析：妥协soundness或者completeness。</p><blockquote><p>Useful static analysis &#x3D; Compromise soundness OR Compromise completeness</p><blockquote><p>Compromise soundness:产生漏报( false negatives ) ( 可以接受 )<br>Compromise completeness:产生误报( false positives ) ( 不希望发生 )</p></blockquote></blockquote><h2 id="3-Static-Analysis-–Bird’s-Eye-View-整体概括"><a href="#3-Static-Analysis-–Bird’s-Eye-View-整体概括" class="headerlink" title="3 - Static Analysis –Bird’s Eye View( 整体概括 )"></a>3 - Static Analysis –Bird’s Eye View( 整体概括 )</h2><p>打破动态思维，从静态分析角度分析代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(input)<br>    x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>    x = <span class="hljs-number">0</span>;<br>-&gt; x = ?<br></code></pre></td></tr></table></figure><p>Sound: x &#x3D; 0, 1, 2, 3<br>Unsound: x &#x3D; -1, 0</p><img src="/images/Introduction/Two-Results.png" width=300 /><p><strong>Static Analysis</strong>: ensure( or get close to )<em>soundness</em>, while making good trade-offs between analysis <em>precision</em> and analysis <em>speed</em>.</p><blockquote><p>在确保 soundness 的前提下，在分析的准确度和速度之间做出有效的平衡。</p></blockquote><h1 id="Two-Words-to-Conclude-Static-Analysis"><a href="#Two-Words-to-Conclude-Static-Analysis" class="headerlink" title="Two Words to Conclude Static Analysis"></a>Two Words to Conclude Static Analysis</h1><h2 id="1-Comprehension"><a href="#1-Comprehension" class="headerlink" title="1 - Comprehension"></a>1 - Comprehension</h2><p><strong>Abstraction + Over - approximation</strong></p><blockquote><p>Abstraction（ 抽象 ）：把具体域的值映射到抽象域的值。</p></blockquote><blockquote><p>Over - approximation（ 近似 ）：在抽象层面定义转移函数；由于无法枚举所有路径，所以使用 flow merging 处理 control flow。</p></blockquote><h1 id="Focus-of-this-section"><a href="#Focus-of-this-section" class="headerlink" title="Focus of this section"></a>Focus of this section</h1><ul><li>静态分析与（动态）测试的区别？</li><li>理解 soundness, completeness, false negatives 和 false positives 的概念</li><li>为什么静态分析需要保证 soundness？</li><li>怎样理解 abstraction 和 over-approximation？</li></ul>]]></content>
    
    
    <categories>
      
      <category>Static Analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NJU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Learning Markdown~</title>
    <link href="/2024/02/19/Learning-Markdown/"/>
    <url>/2024/02/19/Learning-Markdown/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Markdonw"><a href="#一、Markdonw" class="headerlink" title="一、Markdonw"></a>一、Markdonw</h2><p>一款轻量级标记语言。</p><h2 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h2><h3 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h3><blockquote><p>这是一段引用。</p></blockquote><h3 id="列表："><a href="#列表：" class="headerlink" title="列表："></a>列表：</h3><h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>把大象放进冰箱：</p><ol><li>打开冰箱。</li><li>把大象塞进冰箱。</li><li>关上冰箱。</li></ol><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><ul><li>Markdown</li><li>is</li><li>very</li><li>nice</li></ul><h3 id="Todo："><a href="#Todo：" class="headerlink" title="Todo："></a>Todo：</h3><ul><li><input disabled="" type="checkbox"> sleep</li><li><input checked="" disabled="" type="checkbox"> eat</li></ul><h3 id="代码块："><a href="#代码块：" class="headerlink" title="代码块："></a>代码块：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">main</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="表格："><a href="#表格：" class="headerlink" title="表格："></a>表格：</h3><table><thead><tr><th align="left">姓名</th><th align="right">年龄</th><th align="center">成绩</th></tr></thead><tbody><tr><td align="left">张三</td><td align="right">16</td><td align="center">89</td></tr><tr><td align="left">李四</td><td align="right">17</td><td align="center">90</td></tr><tr><td align="left">王五</td><td align="right">17</td><td align="center">95</td></tr></tbody></table><h3 id="链接："><a href="#链接：" class="headerlink" title="链接："></a>链接：</h3><p><a href="github.com" title="代码开源网站">GitHub</a><br><a href="github.com" title="代码开源网站">github</a></p><h3 id="强调："><a href="#强调：" class="headerlink" title="强调："></a>强调：</h3><p><em>斜体</em>,加粗,<code>printf()</code>,:smile:,H<del>2</del>O,X^2^,&#x3D;&#x3D;高亮文字&#x3D;&#x3D;</p><h3 id="嵌入式代码："><a href="#嵌入式代码：" class="headerlink" title="嵌入式代码："></a>嵌入式代码：</h3><iframe src="//player.bilibili.com/player.html?aid=327623069&bvid=BV1JA411h7Gw&cid=171385214&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guangyuan Bacchus Garden Lantern Festival</title>
    <link href="/2024/02/18/%E5%B9%BF%E5%85%83%E7%99%BE%E8%8D%89%E5%9B%AD%E7%81%AF%E4%BC%9A/"/>
    <url>/2024/02/18/%E5%B9%BF%E5%85%83%E7%99%BE%E8%8D%89%E5%9B%AD%E7%81%AF%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<img src="/images/广元百草园灯会/1.jpg"  /><img src="/images/广元百草园灯会/2.jpg"  /><img src="/images/广元百草园灯会/3.jpg"  /><img src="/images/广元百草园灯会/4.jpg"  /><img src="/images/广元百草园灯会/5.jpg"  /><img src="/images/广元百草园灯会/6.jpg"  /><img src="/images/广元百草园灯会/7.jpg"  /><img src="/images/广元百草园灯会/8.jpg"  /><img src="/images/广元百草园灯会/9.jpg"  /><img src="/images/广元百草园灯会/10.jpg"  /><img src="/images/广元百草园灯会/11.jpg"  /><img src="/images/广元百草园灯会/12.jpg"  /><img src="/images/广元百草园灯会/13.jpg"  />]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lantern Festival</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/15/hello-world/"/>
    <url>/2024/02/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
